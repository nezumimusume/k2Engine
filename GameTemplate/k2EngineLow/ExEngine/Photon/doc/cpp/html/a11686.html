<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="UTF-8" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="generator" content="Doxygen 1.8.17"/>
    <meta name="addsearch-custom-field" content="product=realtime"/>
    <meta name="addsearch-custom-field" content="version=current"/>
    <meta name="addsearch-category" content="realtime/current" />
    <title>Photon C++ Client API: Client Class Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link rel="alternate" type="text/xml" title="RSS" href="http://feeds.feedburner.com/exitgamesphoton">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="http://feeds.feedburner.com/exitgamesphoton">
    <!-- For IE: -->
    <link rel="shortcut icon" href="/favicon.ico" type="image/vnd.microsoft.icon">
    <!-- For Browsers, Android: -->
    <link rel="icon" sizes="192x192" href="/touch-icon-192x192.png">
    <link rel="icon" sizes="57x57" href="/apple-touch-icon-precomposed.png">
    <!-- For iPhone 6 Plus: -->
    <link rel="apple-touch-icon-precomposed" sizes="180x180" href="/apple-touch-icon-180x180-precomposed.png">
    <!-- For iPad running iOS = 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/apple-touch-icon-152x152-precomposed.png">
    <!-- For iPhone running iOS = 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/apple-touch-icon-120x120-precomposed.png">
    <!-- For the iPad mini and the first- and second-generation iPad on iOS = 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/apple-touch-icon-76x76-precomposed.png">
    <!-- For non-Retina iPhone, iPod Touch, and Android 2.1+ devices: -->
    <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png">
    <style>
        @charset "UTF-8";
        @import url(//fonts.googleapis.com/css?family=Open+Sans:300,600,700);
        html,
        body {
            height: 100.1%;
        }
        body {
            font-family: "Open Sans", Verdana, Helvetica, Arial, sans-serif;
            line-height: 1.51803398875;
                -webkit-font-smoothing: antialiased;
                -webkit-text-size-adjust: 100%;
            text-rendering: optimizeLegibility;
        }
        #projectname { font-size: 200%; }
        #projectname img {
            vertical-align: sub;
            margin-right: .2em;
        }
    </style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <table cellspacing="0" cellpadding="0" style="width: 100%;">
        <tbody>
            <tr style="height: 56px;">
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">
                        <img alt="" src="logo.png">
                        Photon C++ Client API
                    &#160;<span id="projectnumber">5.0.0.0</span>
                    </div>
                </td>
                <td style="width: 50%;"><gcse:search linktarget="_parent"></gcse:search></td>
            </tr>
        </tbody>
    </table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a10622.html">ExitGames</a></li><li class="navelem"><a class="el" href="a10652.html">LoadBalancing</a></li><li class="navelem"><a class="el" href="a11686.html">Client</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="a11683.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Client Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Client:</div>
<div class="dyncontent">
<div class="center"><img src="a11685.gif" border="0" usemap="#_client_inherit__map" alt="Inheritance graph"/></div>
<map name="_client_inherit__map" id="_client_inherit__map">
<area shape="rect" title=" " alt="" coords="29,149,77,173"/>
<area shape="rect" href="a11654.html" title=" " alt="" coords="5,77,100,101"/>
<area shape="rect" href="a10714.html" title=" " alt="" coords="9,5,96,29"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Client:</div>
<div class="dyncontent">
<div class="center"><img src="a11684.gif" border="0" usemap="#_client_coll__map" alt="Collaboration graph"/></div>
<map name="_client_coll__map" id="_client_coll__map">
<area shape="rect" title=" " alt="" coords="29,149,77,173"/>
<area shape="rect" href="a11654.html" title=" " alt="" coords="5,77,100,101"/>
<area shape="rect" href="a10714.html" title=" " alt="" coords="9,5,96,29"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21ff127a42053e416b4150f8ade01db8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a21ff127a42053e416b4150f8ade01db8">Client</a> (<a class="el" href="a11742.html">LoadBalancing::Listener</a> &amp;listener, const <a class="el" href="a11510.html">Common::JString</a> &amp;applicationID, const <a class="el" href="a11510.html">Common::JString</a> &amp;appVersion, nByte connectionProtocol=Photon::ConnectionProtocol::DEFAULT, bool autoLobbyStats=false, nByte regionSelectionMode=RegionSelectionMode::DEFAULT, bool useAlternativePorts=false)</td></tr>
<tr class="separator:a21ff127a42053e416b4150f8ade01db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298c837a27776ced7055112de6895a4e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a298c837a27776ced7055112de6895a4e">~Client</a> (void)</td></tr>
<tr class="separator:a298c837a27776ced7055112de6895a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952bb842759dee3916ceade681783456"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a952bb842759dee3916ceade681783456">connect</a> (const <a class="el" href="a11690.html">ConnectOptions</a> &amp;connectOptions=<a class="el" href="a11690.html">ConnectOptions</a>())</td></tr>
<tr class="separator:a952bb842759dee3916ceade681783456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888a5acf1fe3a8902f7cb2f5039cb334"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a888a5acf1fe3a8902f7cb2f5039cb334">disconnect</a> (void)</td></tr>
<tr class="separator:a888a5acf1fe3a8902f7cb2f5039cb334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66e8bb0fdc525c5e250092c35343a2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service</a> (bool <a class="el" href="a11686.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands</a>=true)</td></tr>
<tr class="separator:ac66e8bb0fdc525c5e250092c35343a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29567202b6f36cf6805209c2299d912"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ab29567202b6f36cf6805209c2299d912">serviceBasic</a> (void)</td></tr>
<tr class="separator:ab29567202b6f36cf6805209c2299d912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd7a6c0cdc2cf4105043fa2576550cd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#aebd7a6c0cdc2cf4105043fa2576550cd">opCustom</a> (const <a class="el" href="a11646.html">Photon::OperationRequest</a> &amp;operationRequest, bool sendReliable, nByte channelID=0, bool encrypt=false)</td></tr>
<tr class="separator:aebd7a6c0cdc2cf4105043fa2576550cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8607574c36273d920ff3c859d65b5b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands</a> (void)</td></tr>
<tr class="separator:a5f8607574c36273d920ff3c859d65b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab7bcb13d946d8938fb13dc3f7b61e8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a3ab7bcb13d946d8938fb13dc3f7b61e8">sendAcksOnly</a> (void)</td></tr>
<tr class="separator:a3ab7bcb13d946d8938fb13dc3f7b61e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be00ecc71ec66c70629a9064d397d2b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands</a> (void)</td></tr>
<tr class="separator:a4be00ecc71ec66c70629a9064d397d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e6e2243583f7cf42b8123e068302e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ab2e6e2243583f7cf42b8123e068302e9">fetchServerTimestamp</a> (void)</td></tr>
<tr class="separator:ab2e6e2243583f7cf42b8123e068302e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4520fdb8e90d2474bd746b8e106b7ab3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a4520fdb8e90d2474bd746b8e106b7ab3">resetTrafficStats</a> (void)</td></tr>
<tr class="separator:a4520fdb8e90d2474bd746b8e106b7ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bb99da60472492742cb3b20b1b8d7a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ae5bb99da60472492742cb3b20b1b8d7a">resetTrafficStatsMaximumCounters</a> (void)</td></tr>
<tr class="separator:ae5bb99da60472492742cb3b20b1b8d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c452884f78fda542f0a923d104bed05"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a11510.html">Common::JString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a8c452884f78fda542f0a923d104bed05">vitalStatsToString</a> (bool all) const</td></tr>
<tr class="separator:a8c452884f78fda542f0a923d104bed05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4224d3a87a82ac9fcc1fbda851778ddc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a4224d3a87a82ac9fcc1fbda851778ddc">opJoinLobby</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;lobbyName=<a class="el" href="a11510.html">Common::JString</a>(), nByte lobbyType=<a class="el" href="a10658.html#a30c451d8c36cb067661cbe71e62eb2d6">LobbyType::DEFAULT</a>)</td></tr>
<tr class="separator:a4224d3a87a82ac9fcc1fbda851778ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7490f4c8eabace4e51df05948f3ec2f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#aa7490f4c8eabace4e51df05948f3ec2f">opLeaveLobby</a> (void)</td></tr>
<tr class="separator:aa7490f4c8eabace4e51df05948f3ec2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c13655f1d3fc2020769f49f038d5edf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a6c13655f1d3fc2020769f49f038d5edf">opCreateRoom</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;gameID=<a class="el" href="a11510.html">Common::JString</a>(), const <a class="el" href="a11778.html">RoomOptions</a> &amp;options=<a class="el" href="a11778.html">RoomOptions</a>(), const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt; &amp;expectedUsers=<a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt;())</td></tr>
<tr class="separator:a6c13655f1d3fc2020769f49f038d5edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af643e24fb61a69db1d57a7d94c229031"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#af643e24fb61a69db1d57a7d94c229031">opJoinOrCreateRoom</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;gameID, const <a class="el" href="a11778.html">RoomOptions</a> &amp;options=<a class="el" href="a11778.html">RoomOptions</a>(), int cacheSliceIndex=0, const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt; &amp;expectedUsers=<a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt;())</td></tr>
<tr class="separator:af643e24fb61a69db1d57a7d94c229031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf99006cc33efe87eeb8411e6916ded6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#aaf99006cc33efe87eeb8411e6916ded6">opJoinRandomOrCreateRoom</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;gameID=<a class="el" href="a11510.html">Common::JString</a>(), const <a class="el" href="a11778.html">RoomOptions</a> &amp;options=<a class="el" href="a11778.html">RoomOptions</a>(), const <a class="el" href="a10770.html">Common::Hashtable</a> &amp;customRoomProperties=<a class="el" href="a10770.html">Common::Hashtable</a>(), nByte maxPlayers=0, nByte matchmakingMode=<a class="el" href="a10659.html#a86bac20ada21cfddcab4c885fa14b448">MatchmakingMode::FILL_ROOM</a>, const <a class="el" href="a11510.html">Common::JString</a> &amp;lobbyName=<a class="el" href="a11510.html">Common::JString</a>(), nByte lobbyType=<a class="el" href="a10658.html#a30c451d8c36cb067661cbe71e62eb2d6">LobbyType::DEFAULT</a>, const <a class="el" href="a11510.html">Common::JString</a> &amp;sqlLobbyFilter=<a class="el" href="a11510.html">Common::JString</a>(), const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt; &amp;expectedUsers=<a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt;())</td></tr>
<tr class="separator:aaf99006cc33efe87eeb8411e6916ded6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0989c3b651e46f90873c05e46a86fdea"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a0989c3b651e46f90873c05e46a86fdea">opJoinRoom</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;gameID, bool rejoin=false, int cacheSliceIndex=0, const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt; &amp;expectedUsers=<a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt;())</td></tr>
<tr class="separator:a0989c3b651e46f90873c05e46a86fdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432926928eab7d79e3d362aa30dd2059"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a432926928eab7d79e3d362aa30dd2059">opJoinRandomRoom</a> (const <a class="el" href="a10770.html">Common::Hashtable</a> &amp;customRoomProperties=<a class="el" href="a10770.html">Common::Hashtable</a>(), nByte maxPlayers=0, nByte matchmakingMode=<a class="el" href="a10659.html#a86bac20ada21cfddcab4c885fa14b448">MatchmakingMode::FILL_ROOM</a>, const <a class="el" href="a11510.html">Common::JString</a> &amp;lobbyName=<a class="el" href="a11510.html">Common::JString</a>(), nByte lobbyType=<a class="el" href="a10658.html#a30c451d8c36cb067661cbe71e62eb2d6">LobbyType::DEFAULT</a>, const <a class="el" href="a11510.html">Common::JString</a> &amp;sqlLobbyFilter=<a class="el" href="a11510.html">Common::JString</a>(), const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt; &amp;expectedUsers=<a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt;())</td></tr>
<tr class="separator:a432926928eab7d79e3d362aa30dd2059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb426d3ebbe00e7bf2066dae48077e65"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#afb426d3ebbe00e7bf2066dae48077e65">opLeaveRoom</a> (bool willComeBack=false, bool sendAuthCookie=false)</td></tr>
<tr class="separator:afb426d3ebbe00e7bf2066dae48077e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb771a6191f13ded249d55630481bf01"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:acb771a6191f13ded249d55630481bf01"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11686.html#acb771a6191f13ded249d55630481bf01">opRaiseEvent</a> (bool reliable, const Ftype &amp;parameters, nByte eventCode, const <a class="el" href="a11770.html">RaiseEventOptions</a> &amp;options=<a class="el" href="a11770.html">RaiseEventOptions</a>())</td></tr>
<tr class="separator:acb771a6191f13ded249d55630481bf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef2f3dc6081e148aaba4d0a51378c42"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:a8ef2f3dc6081e148aaba4d0a51378c42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11686.html#a8ef2f3dc6081e148aaba4d0a51378c42">opRaiseEvent</a> (bool reliable, const Ftype pParameterArray, typename Common::Helpers::ArrayLengthType&lt; Ftype &gt;::type arrSize, nByte eventCode, const <a class="el" href="a11770.html">RaiseEventOptions</a> &amp;options=<a class="el" href="a11770.html">RaiseEventOptions</a>())</td></tr>
<tr class="separator:a8ef2f3dc6081e148aaba4d0a51378c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a31f8f26f095b3edac41de7554f769d"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:a6a31f8f26f095b3edac41de7554f769d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11686.html#a6a31f8f26f095b3edac41de7554f769d">opRaiseEvent</a> (bool reliable, const Ftype pParameterArray, const short *pArrSizes, nByte eventCode, const <a class="el" href="a11770.html">RaiseEventOptions</a> &amp;options=<a class="el" href="a11770.html">RaiseEventOptions</a>())</td></tr>
<tr class="separator:a6a31f8f26f095b3edac41de7554f769d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62feeb633da4d11b9675dd0bfc41ecf8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a62feeb633da4d11b9675dd0bfc41ecf8">opFindFriends</a> (const <a class="el" href="a11510.html">Common::JString</a> *friendsToFind, short numFriendsToFind)</td></tr>
<tr class="separator:a62feeb633da4d11b9675dd0bfc41ecf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3978b53f44234df440d0096a45dba26a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a3978b53f44234df440d0096a45dba26a">opLobbyStats</a> (const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11746.html">LoadBalancing::LobbyStatsRequest</a> &gt; &amp;lobbiesToQuery=<a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11746.html">LoadBalancing::LobbyStatsRequest</a> &gt;())</td></tr>
<tr class="separator:a3978b53f44234df440d0096a45dba26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a98d2df8a640be7b0bace79d417cfe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a27a98d2df8a640be7b0bace79d417cfe">opChangeGroups</a> (const <a class="el" href="a10810.html">Common::JVector</a>&lt; nByte &gt; *pGroupsToRemove, const <a class="el" href="a10810.html">Common::JVector</a>&lt; nByte &gt; *pGroupsToAdd)</td></tr>
<tr class="separator:a27a98d2df8a640be7b0bace79d417cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc5264127448466bceed827db4729eb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a7dc5264127448466bceed827db4729eb">opCustomAuthenticationSendNextStepData</a> (const <a class="el" href="a11682.html">AuthenticationValues</a> &amp;authenticationValues)</td></tr>
<tr class="separator:a7dc5264127448466bceed827db4729eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae8e7cd169e4d6d85e5749d0f62cad7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#acae8e7cd169e4d6d85e5749d0f62cad7">opWebRpc</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;uriPath)</td></tr>
<tr class="separator:acae8e7cd169e4d6d85e5749d0f62cad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac196509a01a92eb7e1f81a893f09984d"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:ac196509a01a92eb7e1f81a893f09984d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11686.html#ac196509a01a92eb7e1f81a893f09984d">opWebRpc</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;uriPath, const Ftype &amp;parameters, bool sendAuthCookie=false)</td></tr>
<tr class="separator:ac196509a01a92eb7e1f81a893f09984d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa229894c29b022f28ef0a330cc9bb956"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:aa229894c29b022f28ef0a330cc9bb956"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11686.html#aa229894c29b022f28ef0a330cc9bb956">opWebRpc</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;uriPath, const Ftype pParameterArray, typename Common::Helpers::ArrayLengthType&lt; Ftype &gt;::type arrSize, bool sendAuthCookie=false)</td></tr>
<tr class="separator:aa229894c29b022f28ef0a330cc9bb956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8635325563a2e3de8d4423f979a12e80"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:a8635325563a2e3de8d4423f979a12e80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11686.html#a8635325563a2e3de8d4423f979a12e80">opWebRpc</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;uriPath, const Ftype pParameterArray, const short *pArrSizes, bool sendAuthCookie=false)</td></tr>
<tr class="separator:a8635325563a2e3de8d4423f979a12e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea8af9445884b3603d7211c1cdc7588"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#afea8af9445884b3603d7211c1cdc7588">opGetRoomList</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;lobby, const <a class="el" href="a11510.html">Common::JString</a> &amp;sqlLobbyFilter)</td></tr>
<tr class="separator:afea8af9445884b3603d7211c1cdc7588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880c327774ab3184e50570a601739eef"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a880c327774ab3184e50570a601739eef">selectRegion</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;selectedRegion)</td></tr>
<tr class="separator:a880c327774ab3184e50570a601739eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d587503f4c9816c1cfd92c1d09d29e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ae5d587503f4c9816c1cfd92c1d09d29e">reconnectAndRejoin</a> (void)</td></tr>
<tr class="separator:ae5d587503f4c9816c1cfd92c1d09d29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53309df76f7e0b3d7bf77414aef8750d"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:a53309df76f7e0b3d7bf77414aef8750d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11686.html#a53309df76f7e0b3d7bf77414aef8750d">sendDirect</a> (const Ftype &amp;parameters, int targetPlayer, bool fallbackRelay=false)</td></tr>
<tr class="separator:a53309df76f7e0b3d7bf77414aef8750d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b89fe6afd658b684d67d77d0248769"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:a98b89fe6afd658b684d67d77d0248769"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11686.html#a98b89fe6afd658b684d67d77d0248769">sendDirect</a> (const Ftype pParameterArray, typename Common::Helpers::ArrayLengthType&lt; Ftype &gt;::type arrSize, int targetPlayer, bool fallbackRelay=false)</td></tr>
<tr class="separator:a98b89fe6afd658b684d67d77d0248769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e6e1b11758f9f29c0a2dbedfcb0e77"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:ac9e6e1b11758f9f29c0a2dbedfcb0e77"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11686.html#ac9e6e1b11758f9f29c0a2dbedfcb0e77">sendDirect</a> (const Ftype pParameterArray, const short *pArrSizes, int targetPlayer, bool fallbackRelay=false)</td></tr>
<tr class="separator:ac9e6e1b11758f9f29c0a2dbedfcb0e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffe16369e2ae560693625164affafb3"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:a9ffe16369e2ae560693625164affafb3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11686.html#a9ffe16369e2ae560693625164affafb3">sendDirect</a> (const Ftype &amp;parameters, const <a class="el" href="a10810.html">Common::JVector</a>&lt; int &gt; &amp;targetPlayers=<a class="el" href="a10810.html">Common::JVector</a>&lt; int &gt;(), bool fallbackRelay=false)</td></tr>
<tr class="separator:a9ffe16369e2ae560693625164affafb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b3d7d2ef7ffb008a71ab94e1c535a3"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:a23b3d7d2ef7ffb008a71ab94e1c535a3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11686.html#a23b3d7d2ef7ffb008a71ab94e1c535a3">sendDirect</a> (const Ftype pParameterArray, typename Common::Helpers::ArrayLengthType&lt; Ftype &gt;::type arrSize, const <a class="el" href="a10810.html">Common::JVector</a>&lt; int &gt; &amp;targetPlayers=<a class="el" href="a10810.html">Common::JVector</a>&lt; int &gt;(), bool fallbackRelay=false)</td></tr>
<tr class="separator:a23b3d7d2ef7ffb008a71ab94e1c535a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add92be9d33127b06ed4a73df31f103c9"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:add92be9d33127b06ed4a73df31f103c9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11686.html#add92be9d33127b06ed4a73df31f103c9">sendDirect</a> (const Ftype pParameterArray, const short *pArrSizes, const <a class="el" href="a10810.html">Common::JVector</a>&lt; int &gt; &amp;targetPlayers=<a class="el" href="a10810.html">Common::JVector</a>&lt; int &gt;(), bool fallbackRelay=false)</td></tr>
<tr class="separator:add92be9d33127b06ed4a73df31f103c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284335c6f6ff72286cb69bc396f03a20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a284335c6f6ff72286cb69bc396f03a20">sendDirect</a> (const nByte *pParameterArray, int arrSize)</td></tr>
<tr class="separator:a284335c6f6ff72286cb69bc396f03a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f22f30fb0f0ebf638ef1ad46024bc2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#aa2f22f30fb0f0ebf638ef1ad46024bc2">sendDirect</a> (nByte *pParameterArray, int arrSize)</td></tr>
<tr class="separator:aa2f22f30fb0f0ebf638ef1ad46024bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900f6a3f619a74f8bc341f59c69b4380"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a900f6a3f619a74f8bc341f59c69b4380">getServerTimeOffset</a> (void) const</td></tr>
<tr class="separator:a900f6a3f619a74f8bc341f59c69b4380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa108814e82124d5f4af471ea4ffb610a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#aa108814e82124d5f4af471ea4ffb610a">getServerTime</a> (void) const</td></tr>
<tr class="separator:aa108814e82124d5f4af471ea4ffb610a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bf9454763f5626f1192700072c174d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ad4bf9454763f5626f1192700072c174d">getBytesOut</a> (void) const</td></tr>
<tr class="separator:ad4bf9454763f5626f1192700072c174d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8635d0982d8288ca623c8ff69c057c99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a8635d0982d8288ca623c8ff69c057c99">getBytesIn</a> (void) const</td></tr>
<tr class="separator:a8635d0982d8288ca623c8ff69c057c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263a49684b3758d495c41872d56d0957"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a263a49684b3758d495c41872d56d0957">getByteCountCurrentDispatch</a> (void) const</td></tr>
<tr class="separator:a263a49684b3758d495c41872d56d0957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee1554a47db34977491552bcd256d6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a6ee1554a47db34977491552bcd256d6c">getByteCountLastOperation</a> (void) const</td></tr>
<tr class="separator:a6ee1554a47db34977491552bcd256d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e39d83514f8803df537245cf23db14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ac8e39d83514f8803df537245cf23db14">getSentCountAllowance</a> (void) const</td></tr>
<tr class="separator:ac8e39d83514f8803df537245cf23db14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6f199c62967e857482a2e6ae0cd95d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a9a6f199c62967e857482a2e6ae0cd95d">setSentCountAllowance</a> (int sentCountAllowance)</td></tr>
<tr class="separator:a9a6f199c62967e857482a2e6ae0cd95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40fc8e3f6004b9cbd6f99290e6aa4d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#af40fc8e3f6004b9cbd6f99290e6aa4d8">getTimePingInterval</a> (void) const</td></tr>
<tr class="separator:af40fc8e3f6004b9cbd6f99290e6aa4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f6b25436dc87fe34f53c2eec8df65a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#aa7f6b25436dc87fe34f53c2eec8df65a">setTimePingInterval</a> (int timePingInterval)</td></tr>
<tr class="separator:aa7f6b25436dc87fe34f53c2eec8df65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85101f9ea38bc642cb74ec4ae571b9fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a85101f9ea38bc642cb74ec4ae571b9fb">getRoundTripTime</a> (void) const</td></tr>
<tr class="separator:a85101f9ea38bc642cb74ec4ae571b9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace25d38b4d458e3dfb0b670ecd317682"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ace25d38b4d458e3dfb0b670ecd317682">getRoundTripTimeVariance</a> (void) const</td></tr>
<tr class="separator:ace25d38b4d458e3dfb0b670ecd317682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea076259cd369fb751e50467adea2361"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#aea076259cd369fb751e50467adea2361">getTimestampOfLastSocketReceive</a> (void) const</td></tr>
<tr class="separator:aea076259cd369fb751e50467adea2361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee10207cc62f0fa06f3b8853621295a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#acee10207cc62f0fa06f3b8853621295a">getDebugOutputLevel</a> (void) const</td></tr>
<tr class="separator:acee10207cc62f0fa06f3b8853621295a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163e299695ce92d2f02eb4b78b29ab2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a163e299695ce92d2f02eb4b78b29ab2b">setDebugOutputLevel</a> (int debugLevel)</td></tr>
<tr class="separator:a163e299695ce92d2f02eb4b78b29ab2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61033342848847f071fa6d35aff19f37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a11522.html">Common::LogFormatOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a61033342848847f071fa6d35aff19f37">getLogFormatOptions</a> (void) const</td></tr>
<tr class="separator:a61033342848847f071fa6d35aff19f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f7c93e1c773e9369da96bb1e7dd2e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ae5f7c93e1c773e9369da96bb1e7dd2e3">setLogFormatOptions</a> (const <a class="el" href="a11522.html">Common::LogFormatOptions</a> &amp;formatOptions)</td></tr>
<tr class="separator:ae5f7c93e1c773e9369da96bb1e7dd2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7493c7adc48661bc30026674de31d561"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a7493c7adc48661bc30026674de31d561">getIncomingReliableCommandsCount</a> (void) const</td></tr>
<tr class="separator:a7493c7adc48661bc30026674de31d561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ffbf998c2d43f7261e31a3858e3e18"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a57ffbf998c2d43f7261e31a3858e3e18">getPeerID</a> (void) const</td></tr>
<tr class="separator:a57ffbf998c2d43f7261e31a3858e3e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdda1b98b605e108ac6950d9c2d8ff3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#acdda1b98b605e108ac6950d9c2d8ff3b">getDisconnectTimeout</a> (void) const</td></tr>
<tr class="separator:acdda1b98b605e108ac6950d9c2d8ff3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9e8b780e386121f1b33b3f1c95c123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a9f9e8b780e386121f1b33b3f1c95c123">setDisconnectTimeout</a> (int disconnectTimeout)</td></tr>
<tr class="separator:a9f9e8b780e386121f1b33b3f1c95c123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ca352fb9c22793bf6a1f534fd9eedb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a82ca352fb9c22793bf6a1f534fd9eedb">getQueuedIncomingCommands</a> (void) const</td></tr>
<tr class="separator:a82ca352fb9c22793bf6a1f534fd9eedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3173bc58e2727d71e30e6a44279aabcd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a3173bc58e2727d71e30e6a44279aabcd">getQueuedOutgoingCommands</a> (void) const</td></tr>
<tr class="separator:a3173bc58e2727d71e30e6a44279aabcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128dedaab588e53ded9fd9b7708e140b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a128dedaab588e53ded9fd9b7708e140b">getIsPayloadEncryptionAvailable</a> (void) const</td></tr>
<tr class="separator:a128dedaab588e53ded9fd9b7708e140b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb9753eb4af1ebe91f31d0015ee20f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#abeb9753eb4af1ebe91f31d0015ee20f4">getIsEncryptionAvailable</a> (void) const</td></tr>
<tr class="separator:abeb9753eb4af1ebe91f31d0015ee20f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf52333d72638f95904828d4abebdc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#aedf52333d72638f95904828d4abebdc4">getResentReliableCommands</a> (void) const</td></tr>
<tr class="separator:aedf52333d72638f95904828d4abebdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0ae75e5cbd27385fac17357795d239"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a8e0ae75e5cbd27385fac17357795d239">getLimitOfUnreliableCommands</a> (void) const</td></tr>
<tr class="separator:a8e0ae75e5cbd27385fac17357795d239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675a14def7ed1f13d8851c2c509fda44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a675a14def7ed1f13d8851c2c509fda44">setLimitOfUnreliableCommands</a> (int value)</td></tr>
<tr class="separator:a675a14def7ed1f13d8851c2c509fda44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd6583f9b6732f5217b69de3016ef8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#aacd6583f9b6732f5217b69de3016ef8d">getCRCEnabled</a> (void) const</td></tr>
<tr class="separator:aacd6583f9b6732f5217b69de3016ef8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86720f73f3549fe7cec3c48aaaed2dea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a86720f73f3549fe7cec3c48aaaed2dea">setCRCEnabled</a> (bool crcEnabled)</td></tr>
<tr class="separator:a86720f73f3549fe7cec3c48aaaed2dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21ce2fab19a7f89371b55b80e9a6104"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ac21ce2fab19a7f89371b55b80e9a6104">getPacketLossByCRC</a> (void) const</td></tr>
<tr class="separator:ac21ce2fab19a7f89371b55b80e9a6104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63818ef2534cb686799ba4b8089d87b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a63818ef2534cb686799ba4b8089d87b1">getTrafficStatsEnabled</a> (void) const</td></tr>
<tr class="separator:a63818ef2534cb686799ba4b8089d87b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084574cf6d7c3f916dff4b6c23070ade"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a084574cf6d7c3f916dff4b6c23070ade">setTrafficStatsEnabled</a> (bool trafficStatsEnabled)</td></tr>
<tr class="separator:a084574cf6d7c3f916dff4b6c23070ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fd6df74699a45931166b13b8473969"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#aa9fd6df74699a45931166b13b8473969">getTrafficStatsElapsedMs</a> (void) const</td></tr>
<tr class="separator:aa9fd6df74699a45931166b13b8473969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330891f9c5b4bdb083ee510e5dbbe0ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a11674.html">Photon::TrafficStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a330891f9c5b4bdb083ee510e5dbbe0ea">getTrafficStatsIncoming</a> (void) const</td></tr>
<tr class="separator:a330891f9c5b4bdb083ee510e5dbbe0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f3cf485ad2516b5f4a65ddf74914ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a11674.html">Photon::TrafficStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a19f3cf485ad2516b5f4a65ddf74914ad">getTrafficStatsOutgoing</a> (void) const</td></tr>
<tr class="separator:a19f3cf485ad2516b5f4a65ddf74914ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b8575849c266412044dfe7666ff395"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a11678.html">Photon::TrafficStatsGameLevel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a23b8575849c266412044dfe7666ff395">getTrafficStatsGameLevel</a> (void) const</td></tr>
<tr class="separator:a23b8575849c266412044dfe7666ff395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2b890f4b3dd79360358b3afaffd9e8"><td class="memItemLeft" align="right" valign="top">nByte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#adb2b890f4b3dd79360358b3afaffd9e8">getQuickResendAttempts</a> (void) const</td></tr>
<tr class="separator:adb2b890f4b3dd79360358b3afaffd9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a43056816067b306fc0feb54bcd97f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a2a43056816067b306fc0feb54bcd97f5">setQuickResendAttempts</a> (nByte quickResendAttempts)</td></tr>
<tr class="separator:a2a43056816067b306fc0feb54bcd97f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8dacd122e7d5ebaeee1f309a2858b8"><td class="memItemLeft" align="right" valign="top">nByte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a1b8dacd122e7d5ebaeee1f309a2858b8">getChannelCountUserChannels</a> (void) const</td></tr>
<tr class="separator:a1b8dacd122e7d5ebaeee1f309a2858b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7269d12f6ec7a7f81d0c7d8207c34d15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a7269d12f6ec7a7f81d0c7d8207c34d15">getState</a> (void) const</td></tr>
<tr class="separator:a7269d12f6ec7a7f81d0c7d8207c34d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44517d39bb964fc887b0a7a087e47e5b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a44517d39bb964fc887b0a7a087e47e5b">getMasterserverAddress</a> (void) const</td></tr>
<tr class="separator:a44517d39bb964fc887b0a7a087e47e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af307d50f8aff62df93e60770d1ac9128"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#af307d50f8aff62df93e60770d1ac9128">getCountPlayersIngame</a> (void) const</td></tr>
<tr class="separator:af307d50f8aff62df93e60770d1ac9128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1358d18cbbde3bb42ff31e6f09eb8304"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a1358d18cbbde3bb42ff31e6f09eb8304">getCountGamesRunning</a> (void) const</td></tr>
<tr class="separator:a1358d18cbbde3bb42ff31e6f09eb8304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21306efa52d7da26a6aed0996cb1ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a4d21306efa52d7da26a6aed0996cb1ab">getCountPlayersOnline</a> (void) const</td></tr>
<tr class="separator:a4d21306efa52d7da26a6aed0996cb1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be49560fabd180debfd7d6c684b7abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a11758.html">MutableRoom</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a6be49560fabd180debfd7d6c684b7abe">getCurrentlyJoinedRoom</a> (void)</td></tr>
<tr class="separator:a6be49560fabd180debfd7d6c684b7abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362213f78e13ec5c38a46f836976a03b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11774.html">Room</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a362213f78e13ec5c38a46f836976a03b">getRoomList</a> (void) const</td></tr>
<tr class="separator:a362213f78e13ec5c38a46f836976a03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed85654a413546fc23f9f2097ab5d18"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a0ed85654a413546fc23f9f2097ab5d18">getRoomNameList</a> (void) const</td></tr>
<tr class="separator:a0ed85654a413546fc23f9f2097ab5d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d99cc1ff206755096a0befc9e355a3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a3d99cc1ff206755096a0befc9e355a3c">getIsInRoom</a> (void) const</td></tr>
<tr class="separator:a3d99cc1ff206755096a0befc9e355a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bcee6b8cf407301596f2ea8efa88f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ab6bcee6b8cf407301596f2ea8efa88f1">getIsInGameRoom</a> (void) const</td></tr>
<tr class="separator:ab6bcee6b8cf407301596f2ea8efa88f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d4b6a2163b213635c7b9fb49527517"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ad1d4b6a2163b213635c7b9fb49527517">getIsInLobby</a> (void) const</td></tr>
<tr class="separator:ad1d4b6a2163b213635c7b9fb49527517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad8d152e3340453133667a501fd4086"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#afad8d152e3340453133667a501fd4086">getAutoJoinLobby</a> (void) const</td></tr>
<tr class="separator:afad8d152e3340453133667a501fd4086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45e5ba66ec8f4a4ef08c3b499c52593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#aa45e5ba66ec8f4a4ef08c3b499c52593">setAutoJoinLobby</a> (bool autoJoinLobby)</td></tr>
<tr class="separator:aa45e5ba66ec8f4a4ef08c3b499c52593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba431d51ab9d3009ddf6b2776fccca3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a11754.html">MutablePlayer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a2ba431d51ab9d3009ddf6b2776fccca3">getLocalPlayer</a> (void)</td></tr>
<tr class="separator:a2ba431d51ab9d3009ddf6b2776fccca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d297b0e3b0a3545d2c63e029bcf562"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11694.html">FriendInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#ab3d297b0e3b0a3545d2c63e029bcf562">getFriendList</a> (void) const</td></tr>
<tr class="separator:ab3d297b0e3b0a3545d2c63e029bcf562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61b642c390d6448ad2fd30ce90f0c07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#af61b642c390d6448ad2fd30ce90f0c07">getFriendListAge</a> (void) const</td></tr>
<tr class="separator:af61b642c390d6448ad2fd30ce90f0c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f1adb2a9394f24aa7ce42b281e99b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a03f1adb2a9394f24aa7ce42b281e99b9">getDisconnectedCause</a> (void) const</td></tr>
<tr class="separator:a03f1adb2a9394f24aa7ce42b281e99b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3452520ad1bd930bf6e7f62be14fb609"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a3452520ad1bd930bf6e7f62be14fb609">getUserID</a> (void) const</td></tr>
<tr class="separator:a3452520ad1bd930bf6e7f62be14fb609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ccef9856816076a0affd88619319e0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a91ccef9856816076a0affd88619319e0">getRegionWithBestPing</a> (void) const</td></tr>
<tr class="separator:a91ccef9856816076a0affd88619319e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a10359924120048ca6281db6ed9dda97d"><td class="memItemLeft" align="right" valign="top">static short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11686.html#a10359924120048ca6281db6ed9dda97d">getPeerCount</a> (void)</td></tr>
<tr class="separator:a10359924120048ca6281db6ed9dda97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements the Photon LoadBalancing work flow by using a <a class="el" href="a11762.html">Peer</a>. It keeps a state and automatically executes transitions between the Master and Game Servers.</p>
<p>This class (and the <a class="el" href="a11766.html">Player</a>, <a class="el" href="a11754.html">MutablePlayer</a>, <a class="el" href="a11774.html">Room</a> and <a class="el" href="a11758.html">MutableRoom</a> classes) might be extended to implement your own logic.</p>
<p>However this is not necessary. You can also just put your game specific network logic into a class that uses this class as is, which is the recommended approach.</p>
<p>Override <a class="el" href="a11758.html">MutableRoom</a>:createPlayer() when subclassing <a class="el" href="a11766.html">Player</a>, getMutablePlayerFactory() + MutablePlayerFactory::create() + MutablePlayerFactory::destroy() when subclassing <a class="el" href="a11754.html">MutablePlayer</a>, createRoom() when subclassing <a class="el" href="a11774.html">Room</a> and getMutableRoomFactory() + MutableRoomFactory::create() + MutableRoomFactory::destroy() when subclassing <a class="el" href="a11758.html">MutableRoom</a>. </p><dl class="section remark"><dt>Remarks</dt><dd>Extension notes: An extension of this class should override the functions that are inherited from <a class="el" href="a11654.html">Photon::PhotonListener</a>, as they are called when the state changes. Call the base implementation first, then pick the operation response, event or state that you want to react to and put it in a switch-case.</dd></dl>
<p>We try to provide demos to each platform where this API can be used, so lookout for those. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a21ff127a42053e416b4150f8ade01db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ff127a42053e416b4150f8ade01db8">&#9670;&nbsp;</a></span>Client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a11686.html">Client</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a11742.html">LoadBalancing::Listener</a> &amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>applicationID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>appVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>connectionProtocol</em> = <code>Photon::ConnectionProtocol::DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoLobbyStats</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>regionSelectionMode</em> = <code>RegionSelectionMode::DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlternativePorts</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>Reference to the application's implementation of the <a class="el" href="a11742.html">Listener</a> callback interface. Has to be valid for at least the lifetime of the <a class="el" href="a11686.html">Client</a> instance, which is created by this constructor. </td></tr>
    <tr><td class="paramname">applicationID</td><td>A unique ID of your application. Must match one of the appIDs in your dashboard for Photon Cloud. This parameter gets ignored by Photon Server. </td></tr>
    <tr><td class="paramname">appVersion</td><td>Only clients that use the exact same appVersion can see each other. You can use different values to separate clients with the same appID from each other that should not be able to be matched with each other or to even see each other, i.e. incompatible versions of your game or public, closed-beta, QA, staging and dev clients. This parameter gets ignored by Photon Server. </td></tr>
    <tr><td class="paramname">connectionProtocol</td><td>The protocol to use to connect to the Photon servers. Must match one of the constants specified in ConnectionProtocol. </td></tr>
    <tr><td class="paramname">autoLobbyStats</td><td>Pass true, if you want to automatically receive updates for the lobby stats, false otherwise. Call <a class="el" href="a11686.html#a3978b53f44234df440d0096a45dba26a">opLobbyStats()</a> to explicitly request a lobby stats update. </td></tr>
    <tr><td class="paramname">regionSelectionMode</td><td>Determines how the Photon Cloud Region to which the <a class="el" href="a11686.html">Client</a> connects should be selected. Must match one of the constants specified in RegionSelectionMode. This parameter gets ignored when connecting to Photon Server. </td></tr>
    <tr><td class="paramname">useAlternativePorts</td><td>Determines if the the standard or the alternative port range should be used. This parameter currently is only relevant when ConnectionProtocol::UDP is passed for parameter connectionProtocol and gets ignored otherwise. A router or firewall might block connections that use one port-range but don't block connections that use the other, so when connecting with one range fails, then you may want to try with the other one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11742.html">Listener</a>, ConnectionProtocol, RegionSelectionMode, NetworkPort </dd></dl>

</div>
</div>
<a id="a298c837a27776ced7055112de6895a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298c837a27776ced7055112de6895a4e">&#9670;&nbsp;</a></span>~Client()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="a11686.html">Client</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a952bb842759dee3916ceade681783456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952bb842759dee3916ceade681783456">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11690.html">ConnectOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>connectOptions</em> = <code><a class="el" href="a11690.html">ConnectOptions</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function starts establishing a connection to a Photon server. The servers response will arrive in Listener::connectReturn().</p>
<p>The connection is successfully established when the Photon client received a valid response from the server. The connect-attempt fails when a network error occurs or when server is not responding. A call to this function starts an asynchronous operation. The result of this operation gets returned through the Listener::connectReturn() callback function. If this function returns false, then the connect-attempt has already failed locally. If it returns true, then either Listener::connectionErrorReturn() or Listener::connectReturn() will get called. The operation was successful, when Listener::connectReturn() got called with errorCode==0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connectOptions</td><td>An instance of class <a class="el" href="a11690.html">ConnectOptions</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if it could successfully start establishing a connection (the result will be provided in a callback function in this case) or false, if an error occurred and the connection could not be established (no callback function will be called then). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a888a5acf1fe3a8902f7cb2f5039cb334">disconnect()</a>, NetworkPort </dd></dl>

</div>
</div>
<a id="a888a5acf1fe3a8902f7cb2f5039cb334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888a5acf1fe3a8902f7cb2f5039cb334">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void disconnect </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function generates a disconnection request that will be sent to the Photon server. The servers response will arrive in Listener::disconnectReturn().</p>
<p>If the disconnection is completed successfully, then the Listener::disconnectReturn() callback will be called.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If a game room is joined, when this function gets called, then the local player leaves that room as if <a class="el" href="a11686.html#afb426d3ebbe00e7bf2066dae48077e65">opLeaveRoom()</a> has been called with parameter 'willComeBack' set to 'true'. Please see there for further information about leaving rooms. However no call to Listener::leaveRoomReturn() will happen when leaving a game room is triggered through a call to <a class="el" href="a11686.html#a888a5acf1fe3a8902f7cb2f5039cb334">disconnect()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a952bb842759dee3916ceade681783456">connect()</a>, <a class="el" href="a11686.html#afb426d3ebbe00e7bf2066dae48077e65">opLeaveRoom()</a> </dd></dl>

</div>
</div>
<a id="ac66e8bb0fdc525c5e250092c35343a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66e8bb0fdc525c5e250092c35343a2d">&#9670;&nbsp;</a></span>service()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void service </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dispatchIncomingCommands</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This function executes the PhotonPeer internal processes. Call this regularly!</p>
<p>This function is meant to be called frequently, like once per game loop. It handles the internal calls for keeping the PhotonPeer communication alive, and will take care of sending all local outgoing acknowledgements and messages, as well as dispatching incoming messages to the application and firing the corresponding callbacks. Internally <a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> calls the following functions:</p><ol type="1">
<li><a class="el" href="a11686.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a></li>
<li><a class="el" href="a11686.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> (called withing a loop until all incoming commands have been dispatched.)</li>
<li><a class="el" href="a11686.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> (called withing a loop until everything queued for sending has been sent.)</li>
</ol>
<p><a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> is provided for convenience. If you need to tweak the performance, you can ignore <a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> and call its three subfunctions directly with individual time intervals, to gain more control over the internal communication process. For instance, calling <a class="el" href="a11686.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> more rarely will result in less packets to be generated, as more commands will be accumulated into a single packet. See <a class="el" href="a11686.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> for more information on efficiency.</p>
<p>For situations where you want to keep the connection alive, but can't process incoming messages (e.g. when loading a level), you can temporarily pass false for dispatchIncomingCommands to skip the calls to <a class="el" href="a11686.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a>. Incoming commands will be stored in the incoming queue until they are dispatched again. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatchIncomingCommands</td><td>true = <a class="el" href="a11686.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> will be called; false = <a class="el" href="a11686.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> won't be called, default is true </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab29567202b6f36cf6805209c2299d912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29567202b6f36cf6805209c2299d912">&#9670;&nbsp;</a></span>serviceBasic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serviceBasic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This function takes care of exchanging data with the system's network layer.</p>
<p>You only need to call this function in case you choose not to use <a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a>, but call the subfunctions of <a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> directly. Please see the documentation of <a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> for more information.</p>
<p><a class="el" href="a11686.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> is called from within <a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a>. If you decide not to use <a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a>, then <a class="el" href="a11686.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> needs to be called frequently, like once per game loop. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> </dd></dl>

</div>
</div>
<a id="aebd7a6c0cdc2cf4105043fa2576550cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd7a6c0cdc2cf4105043fa2576550cd">&#9670;&nbsp;</a></span>opCustom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opCustom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11646.html">Photon::OperationRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>operationRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sendReliable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>channelID</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>encrypt</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Sends a custom operation to a custom Server, using reliable or unreliable Photon transmission.</p>
<p>Allows the client to send a custom operation to the Photon server (which has to be modified accordingly). The Server can be extended and modified for special purposes like server side collision detection or a consistent world.</p>
<p>You need to be connected (see <a class="el" href="a11686.html#a952bb842759dee3916ceade681783456">connect()</a>) prior to calling <a class="el" href="a11686.html#aebd7a6c0cdc2cf4105043fa2576550cd">opCustom()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operationRequest</td><td>holds the payload of the operation </td></tr>
    <tr><td class="paramname">sendReliable</td><td>= operation will be sent reliably; false = no resend in case of packet loss - will be ignored, when not using udp as protocol </td></tr>
    <tr><td class="paramname">channelID</td><td>the logical channel, default is 0. See <a class="el" href="a12696.html">Fragmentation and Channels</a> for more information. </td></tr>
    <tr><td class="paramname">encrypt</td><td>true = encrypt message; false = no encryption </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if successful, false otherwise </dd></dl>

</div>
</div>
<a id="a5f8607574c36273d920ff3c859d65b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8607574c36273d920ff3c859d65b5b">&#9670;&nbsp;</a></span>sendOutgoingCommands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sendOutgoingCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This function initiates the transmission of outgoing commands.</p>
<p>Any Photon function that generates messages will store these messages as a "command" in an outgoing queue for later transmission. Commands can either be explicitly created operations generated for example by <a class="el" href="a11686.html#aebd7a6c0cdc2cf4105043fa2576550cd">opCustom()</a> or internally generated messages like acknowledgements for reliable messages from other players. <a class="el" href="a11686.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> will initiate the data transmission by passing the outgoing commands to the system's sockets for immediate transmission.</p>
<p>In case of UDP <a class="el" href="a11686.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> will also split the commands into multiple packets if needed and/of aggregate multiple commands together into one packet, if possible. Because of the latter calling sendOutgoingcommands() more rarely will result in less overhead, as there will be fewer packets for the clients to be sent and processed. The underlying platform can also limit the frequency in which outgoing packets can be sent and received. The downside of lower sending frequencies is a higher latency, until messages are exchanged and acknowledged, which may lead to a jerky gameplay.</p>
<p>To help you keeping track of the incoming and outgoing queues at development time and adjust your sending frequency, there will be a warning message sent to your debugReturn callback if a queue has exceeded the warning threshold. </p><dl class="section note"><dt>Note</dt><dd>While <a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> is calling <a class="el" href="a11686.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> implicitly, you will have to regularly call it yourself explictly , when you use <a class="el" href="a11686.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> and <a class="el" href="a11686.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> directly instead.</dd></dl>
<p>Usually you don't have to call <a class="el" href="a11686.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> this explicitly, as this is done within <a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> </dd></dl>

</div>
</div>
<a id="a3ab7bcb13d946d8938fb13dc3f7b61e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab7bcb13d946d8938fb13dc3f7b61e8">&#9670;&nbsp;</a></span>sendAcksOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sendAcksOnly </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Sends only ACKs (UDP) or Ping (TCP) instead of queued outgoing commands. Useful to pause sending actual data. </p><dl class="section note"><dt>Note</dt><dd>While <a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> is calling <a class="el" href="a11686.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> implicitly, you will have to regularly call it yourself explictly , when you use <a class="el" href="a11686.html#a3ab7bcb13d946d8938fb13dc3f7b61e8">sendAcksOnly()</a> and <a class="el" href="a11686.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> instead. </dd></dl>

</div>
</div>
<a id="a4be00ecc71ec66c70629a9064d397d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be00ecc71ec66c70629a9064d397d2b">&#9670;&nbsp;</a></span>dispatchIncomingCommands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dispatchIncomingCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Checks for incoming commands waiting in the queue, and dispatches a single command to the application.</p>
<p>Dispatching means, that if the command is an operation response or an event, the appropriate callback function will be called). <a class="el" href="a11686.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> will also take care of generating and queuing acknowledgments for incoming reliable commands. Please note that this function will only dispatch one command per all. If you want to dispatch every single command which is waiting in the queue, call dipatchIncomingCommands() within a while loop, until its return code is false. </p><dl class="section note"><dt>Note</dt><dd>While <a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> is calling <a class="el" href="a11686.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> implicitly, you will have to regularly call it yourself explictly, when you use <a class="el" href="a11686.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> and <a class="el" href="a11686.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> directly instead. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if it has successfully dispatched a command, false otherwise (for example, when there has not been any command left in the queue, waiting for dispatching). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> </dd></dl>

</div>
</div>
<a id="ab2e6e2243583f7cf42b8123e068302e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e6e2243583f7cf42b8123e068302e9">&#9670;&nbsp;</a></span>fetchServerTimestamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fetchServerTimestamp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This will fetch the server's timestamp and update the approximation for <a class="el" href="a11686.html#aa108814e82124d5f4af471ea4ffb610a">getServerTime()</a> and <a class="el" href="a11686.html#a900f6a3f619a74f8bc341f59c69b4380">getServerTimeOffset()</a>.</p>
<p>The server time approximation will NOT become more accurate by repeated calls. Accuracy currently depends on a single roundtrip which is done as fast as possible.</p>
<p>The command used for this is immediately acknowledged by the server. This makes sure the roundtriptime is low and the timestamp + roundtriptime / 2 is close to the original value. </p>

</div>
</div>
<a id="a4520fdb8e90d2474bd746b8e106b7ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4520fdb8e90d2474bd746b8e106b7ab3">&#9670;&nbsp;</a></span>resetTrafficStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resetTrafficStats </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Creates new instances of TrafficStats and starts a new timer for those. </p>

</div>
</div>
<a id="ae5bb99da60472492742cb3b20b1b8d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bb99da60472492742cb3b20b1b8d7a">&#9670;&nbsp;</a></span>resetTrafficStatsMaximumCounters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resetTrafficStatsMaximumCounters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Resets traffic stats values that can be maxed out. </p>

</div>
</div>
<a id="a8c452884f78fda542f0a923d104bed05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c452884f78fda542f0a923d104bed05">&#9670;&nbsp;</a></span>vitalStatsToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a11510.html">Common::JString</a> vitalStatsToString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Returns a string of the most interesting connection statistics. When you have issues on the client side, these might contain hints about the issue's cause. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">all</td><td>If true, Incoming and Outgoing low-level stats are included in the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stats as a string. </dd></dl>

</div>
</div>
<a id="a4224d3a87a82ac9fcc1fbda851778ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4224d3a87a82ac9fcc1fbda851778ddc">&#9670;&nbsp;</a></span>opJoinLobby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opJoinLobby </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>lobbyName</em> = <code><a class="el" href="a11510.html">Common::JString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>lobbyType</em> = <code><a class="el" href="a10658.html#a30c451d8c36cb067661cbe71e62eb2d6">LobbyType::DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Joins the specified lobby.</p>
<p>This function sends a request to the server to join the specified lobby. If it returns true, then Listener::joinLobbyReturn() gets called when the operation has successfully been finished. Please see <a href="https://doc.photonengine.com/en/realtime/current/reference/matchmaking-and-lobby">Matchmaking Guide</a> regarding the differences between the various lobby types. </p><dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="a11686.html">Client</a> instance can only be inside one room at a time. Therefor this operation will fail and return false, if the client is already inside another lobby or inside a game room. Leave the other room first, before calling this operation. </dd>
<dd>
For the same reason entering a game room implicitly causes the client to leave the lobby, so if you want to return to the previously joined lobby after leaving that game room, you must explicitly join it again. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the auto-join lobby feature is enabled (which is the default! - it can be turned off by a call to <a class="el" href="a11686.html#aa45e5ba66ec8f4a4ef08c3b499c52593">setAutoJoinLobby()</a>), then the client automatically joins the default lobby when successfully connecting to <a class="el" href="a10635.html">Photon</a> and when leaving a game room. Call setAutoJoinLobby(false) before calling <a class="el" href="a11686.html#a952bb842759dee3916ceade681783456">connect()</a> for <a class="el" href="a11686.html#a4224d3a87a82ac9fcc1fbda851778ddc">opJoinLobby()</a> to work properly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lobbyName</td><td>the unique name of the lobby to join </td></tr>
    <tr><td class="paramname">lobbyType</td><td>one of the values in <a class="el" href="a10658.html">LobbyType</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#aa7490f4c8eabace4e51df05948f3ec2f">opLeaveLobby()</a>, <a class="el" href="a11686.html#aa45e5ba66ec8f4a4ef08c3b499c52593">setAutoJoinLobby()</a>, <a class="el" href="a11686.html#afad8d152e3340453133667a501fd4086">getAutoJoinLobby()</a>, Listener::joinLobbyReturn() </dd></dl>

</div>
</div>
<a id="aa7490f4c8eabace4e51df05948f3ec2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7490f4c8eabace4e51df05948f3ec2f">&#9670;&nbsp;</a></span>opLeaveLobby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opLeaveLobby </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Leaves the currently joined lobby.</p>
<p>This function sends a request to the server to leave the currently joined lobby. If it returns true, then Listener::leaveLobbyReturn() gets called when the operation has successfully been finished. </p><dl class="section remark"><dt>Remarks</dt><dd>This operation will fail and return false if the client does not currently reside inside any lobby. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a4224d3a87a82ac9fcc1fbda851778ddc">opJoinLobby()</a>, Listener::leaveLobbyReturn() </dd></dl>

</div>
</div>
<a id="a6c13655f1d3fc2020769f49f038d5edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c13655f1d3fc2020769f49f038d5edf">&#9670;&nbsp;</a></span>opCreateRoom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opCreateRoom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>gameID</em> = <code><a class="el" href="a11510.html">Common::JString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11778.html">RoomOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="a11778.html">RoomOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expectedUsers</em> = <code><a class="el" href="a10810.html">Common::JVector</a>&lt;<a class="el" href="a11510.html">Common::JString</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates and enters a new game room.</p>
<p>This function sends a request to the server to create the specified game room. If it returns true, then Listener::createRoomReturn() gets called when the operation has been finished.</p>
<p>If you don't want to create a unique room name, pass L"" as name and the server will assign a roomName (a GUID as string). Room names are unique.</p>
<p>A room will be attached to the lobby that you have specified in the provided options. Leave the lobby name empty to attach the room to the lobby in which you reside at the time of room creation. If you are in no lobby, then the default lobby is used.</p>
<p>Multiple lobbies can help to separate players by map or skill or game type. Each room can only be found in one lobby (no matter if defined by name and type or as default). </p><dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="a11686.html">Client</a> instance can only be inside one room at a time. Therefor this operation will fail and return false, if the client is already inside another game room. Any lobby the client currently resides in will implicitly be left when entering a game room. </dd>
<dd>
If a room with the specified name does already exist, then the operation will fail and Listener::createRoomReturn() will get called with an error code. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gameID</td><td>The name to create a room with. Must be unique and not in use or the room can't be created. If this is an empty string, then the server will assign a GUID as name. </td></tr>
    <tr><td class="paramname">options</td><td>An instance of <a class="el" href="a11778.html">RoomOptions</a>, that can be used to specify various options for room creation. </td></tr>
    <tr><td class="paramname">expectedUsers</td><td>Sets a list of user IDs for which the server should reserve slots. Those slots can't be taken by other players. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#af643e24fb61a69db1d57a7d94c229031">opJoinOrCreateRoom()</a>, <a class="el" href="a11686.html#aaf99006cc33efe87eeb8411e6916ded6">opJoinRandomOrCreateRoom()</a>, <a class="el" href="a11686.html#a0989c3b651e46f90873c05e46a86fdea">opJoinRoom()</a>, <a class="el" href="a11686.html#a432926928eab7d79e3d362aa30dd2059">opJoinRandomRoom()</a>, <a class="el" href="a11686.html#afb426d3ebbe00e7bf2066dae48077e65">opLeaveRoom()</a>, <a class="el" href="a11758.html">MutableRoom</a>, <a class="el" href="a11778.html">RoomOptions</a>, Listener::createRoomReturn() </dd></dl>

</div>
</div>
<a id="af643e24fb61a69db1d57a7d94c229031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af643e24fb61a69db1d57a7d94c229031">&#9670;&nbsp;</a></span>opJoinOrCreateRoom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opJoinOrCreateRoom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>gameID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11778.html">RoomOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="a11778.html">RoomOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cacheSliceIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expectedUsers</em> = <code><a class="el" href="a10810.html">Common::JVector</a>&lt;<a class="el" href="a11510.html">Common::JString</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Joins the specified game room or creates and enters a new game room with the specified ID if such a room does not exist yet.</p>
<p>This function sends a request to the server to join the specified game room if exists and to create it otherwise. If it returns true, then Listener::joinOrCreateRoomReturn() gets called when the operation has been finished.</p>
<p>Unlike <a class="el" href="a11686.html#a0989c3b651e46f90873c05e46a86fdea">opJoinRoom()</a>, this operation does not fail if the room does not exist. This can be useful when you send invitations to a room before actually creating it: Any invited player (whoever is first) can call this and on demand, the room gets created implicitly.</p>
<p>In the case that a new room gets created, that room will be attached to the lobby that you have specified in the provided options. Leave the lobby name empty to attach the room to the lobby in which you reside at the time of room creation. If you are in no lobby, then the default lobby is used.</p>
<p>This operation does not allow you to re-join a game. To return to a room, use <a class="el" href="a11686.html#a0989c3b651e46f90873c05e46a86fdea">opJoinRoom()</a> with the playerNumber which was assigned previously. </p><dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="a11686.html">Client</a> instance can only be inside one room at a time. Therefor this operation will fail and return false, if the client is already inside another game room. Any lobby the client currently resides in will implicitly be left when entering a game room. </dd>
<dd>
If the room is full or closed, then this operation will fail and Listener::joinOrCreateRoomReturn() will get called with an error code. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gameID</td><td>A unique identifier for the game room to join or create. If this is an empty string, then the server will create a room and assign a GUID as name. </td></tr>
    <tr><td class="paramname">options</td><td>An instance of <a class="el" href="a11778.html">RoomOptions</a>, that can be used to specify various options for room creation. These options will be ignored when the room already exists. </td></tr>
    <tr><td class="paramname">cacheSliceIndex</td><td>Allows to request a specific cache slice - all events in that cache slice and upward slices will be published to the client after joining the room - see <a class="el" href="a10639.html">Lite::EventCache</a> for further information about cached events. </td></tr>
    <tr><td class="paramname">expectedUsers</td><td>Sets a list of user IDs for which the server should reserve slots. Those slots can't be taken by other players. If the room already exists, then this list will be merged with any previously set list of expected users for this room. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a6c13655f1d3fc2020769f49f038d5edf">opCreateRoom()</a>, <a class="el" href="a11686.html#aaf99006cc33efe87eeb8411e6916ded6">opJoinRandomOrCreateRoom()</a>, <a class="el" href="a11686.html#a0989c3b651e46f90873c05e46a86fdea">opJoinRoom()</a>, <a class="el" href="a11686.html#a432926928eab7d79e3d362aa30dd2059">opJoinRandomRoom()</a>, <a class="el" href="a11686.html#afb426d3ebbe00e7bf2066dae48077e65">opLeaveRoom()</a>, <a class="el" href="a11758.html">MutableRoom</a>, <a class="el" href="a11778.html">RoomOptions</a>, Listener::joinOrCreateRoomReturn() </dd></dl>

</div>
</div>
<a id="aaf99006cc33efe87eeb8411e6916ded6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf99006cc33efe87eeb8411e6916ded6">&#9670;&nbsp;</a></span>opJoinRandomOrCreateRoom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opJoinRandomOrCreateRoom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>gameID</em> = <code><a class="el" href="a11510.html">Common::JString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11778.html">RoomOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="a11778.html">RoomOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a10770.html">Common::Hashtable</a> &amp;&#160;</td>
          <td class="paramname"><em>customRoomProperties</em> = <code><a class="el" href="a10770.html">Common::Hashtable</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>maxPlayers</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>matchmakingMode</em> = <code><a class="el" href="a10659.html#a86bac20ada21cfddcab4c885fa14b448">MatchmakingMode::FILL_ROOM</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>lobbyName</em> = <code><a class="el" href="a11510.html">Common::JString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>lobbyType</em> = <code><a class="el" href="a10658.html#a30c451d8c36cb067661cbe71e62eb2d6">LobbyType::DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>sqlLobbyFilter</em> = <code><a class="el" href="a11510.html">Common::JString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expectedUsers</em> = <code><a class="el" href="a10810.html">Common::JVector</a>&lt;<a class="el" href="a11510.html">Common::JString</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Joins a random game room that matches the specified criteria or creates and enters a new game room with the specified ID if such a room does not exist yet.</p>
<p>This function sends a request to the server to join a random game room that matches the specified filters if such a room exists and to create it otherwise. If it returns true, then Listener::joinRandomOrCreateRoomReturn() gets called when the operation has been finished.</p>
<p>Unlike <a class="el" href="a11686.html#a432926928eab7d79e3d362aa30dd2059">opJoinRandomRoom()</a>, this operation does not fail if no room exists, that matches the specified criteria, but creates a new room.</p>
<p>In the case that a new room gets created, that room will be attached to the lobby that you have specified in the provided options. Leave the lobby name empty to attach the room to the lobby in which you reside at the time of room creation. If you are in no lobby, then the default lobby is used. </p><dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="a11686.html">Client</a> instance can only be inside one room at a time. Therefor this operation will fail and return false, if the client is already inside another game room. Any lobby the client currently resides in will implicitly be left when entering a game room. </dd>
<dd>
If no rooms are fitting or available (all full, closed or not visible), then this operation will create a new room with the specified gameID and the specified room options. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gameID</td><td>A unique identifier for the game room to create. This parameter only gets considered if no existing room matches the specified filters and a new room gets created. If this is an empty string, then the server will create a room and assign a GUID as name. </td></tr>
    <tr><td class="paramname">options</td><td>An instance of <a class="el" href="a11778.html">RoomOptions</a>, that can be used to specify various options for room creation. These options only get considered if no existing room matches the filters and a new room gets created. </td></tr>
    <tr><td class="paramname">customRoomProperties</td><td>Used as a filter for matchmaking. The server only considers rooms for which all custom properties match the specified filters. Note that only those custom room properties that have been specified for listing in the lobby will be used for matchmaking, so a rooms custom property can only match a specified filter if it got specified in the list of properties to show in the lobby. All values must be exact matches. </td></tr>
    <tr><td class="paramname">maxPlayers</td><td>Must match the value of a rooms maxPlayers property for that room to be considered for matchmaking. </td></tr>
    <tr><td class="paramname">matchmakingMode</td><td>Needs to be one of the values in MatchMakingMode </td></tr>
    <tr><td class="paramname">lobbyName</td><td>The name of the lobby in which matchmaking should take place. Only rooms that are listed in that lobby will be considered for matchmaking. </td></tr>
    <tr><td class="paramname">lobbyType</td><td>The type of the lobby in which matchmaking should take place. Needs to be one of the values in <a class="el" href="a10658.html">LobbyType</a>. Note that a lobby with the same name, but a different type can not be considered for matchmaking, as a lobby name only needs to be unique among lobbies of the same type. </td></tr>
    <tr><td class="paramname">sqlLobbyFilter</td><td>Only used for <a class="el" href="a10658.html#ac886f0e0011a225062d0e23fc69627f4" title="This lobby type lists rooms like type DEFAULT but SQL-like &quot;where&quot; clauses for filtering can be used ...">LobbyType::SQL_LOBBY</a>. This allows 'bigger', 'less', 'or' and 'and' combinations for filtering against certain room properties. Up to 3 ';'-separated filters can be specified. The second filter will only be considered if no rooms could be found that match the first filter and the third filter will only be considered if no rooms could be found that match either the first or the second filter. </td></tr>
    <tr><td class="paramname">expectedUsers</td><td>Sets a list of user IDs for which the server should reserve slots. Those slots can't be taken by other players. This list will be merged with any previously set list of expected users for this room. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a6c13655f1d3fc2020769f49f038d5edf">opCreateRoom()</a>, <a class="el" href="a11686.html#af643e24fb61a69db1d57a7d94c229031">opJoinOrCreateRoom()</a>, <a class="el" href="a11686.html#a0989c3b651e46f90873c05e46a86fdea">opJoinRoom()</a>, <a class="el" href="a11686.html#a432926928eab7d79e3d362aa30dd2059">opJoinRandomRoom()</a>, <a class="el" href="a11686.html#afb426d3ebbe00e7bf2066dae48077e65">opLeaveRoom()</a>, <a class="el" href="a11758.html">MutableRoom</a>, Listener::joinRandomOrCreateRoomReturn(), <a href="https://doc.photonengine.com/en-us/realtime/current/reference/matchmaking-and-lobby">Matchmaking and Lobby</a> </dd></dl>

</div>
</div>
<a id="a0989c3b651e46f90873c05e46a86fdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0989c3b651e46f90873c05e46a86fdea">&#9670;&nbsp;</a></span>opJoinRoom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opJoinRoom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>gameID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rejoin</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cacheSliceIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expectedUsers</em> = <code><a class="el" href="a10810.html">Common::JVector</a>&lt;<a class="el" href="a11510.html">Common::JString</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Joins the specified game room.</p>
<p>This function sends a request to the server to join the specified game room. If it returns true, then Listener::joinRoomReturn() gets called when the operation has been finished.</p>
<p>This function is useful when you are using a lobby to list rooms and know their names. A room's name has to be unique (per region and app version), so it does not matter which lobby the room is in.</p>
<p>It's usually better to use <a class="el" href="a11686.html#af643e24fb61a69db1d57a7d94c229031">opJoinOrCreateRoom()</a> for invitations. Then it does not matter if the room is already setup. </p><dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="a11686.html">Client</a> instance can only be inside one room at a time. Therefor this operation will fail and return false, if the client is already inside another game room. Any lobby the client currently resides in will implicitly be left when entering a game room. </dd>
<dd>
If a room with the specified name does not exist or if the room is full or closed, then this operation will fail and Listener::joinRoomReturn() will get called with an error code. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gameID</td><td>A unique identifier for the game room to join. </td></tr>
    <tr><td class="paramname">rejoin</td><td>Needs to be false if this is the initial join of this room for this client and true if this is a rejoin. </td></tr>
    <tr><td class="paramname">cacheSliceIndex</td><td>Allows to request a specific cache slice - all events in that cache slice and upward slices will be published to the client after joining the room - see <a class="el" href="a10639.html">Lite::EventCache</a> for further information about cached events. </td></tr>
    <tr><td class="paramname">expectedUsers</td><td>Sets a list of user IDs for which the server should reserve slots. Those slots can't be taken by other players. This list will be merged with any previously set list of expected users for this room. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a6c13655f1d3fc2020769f49f038d5edf">opCreateRoom()</a>, <a class="el" href="a11686.html#af643e24fb61a69db1d57a7d94c229031">opJoinOrCreateRoom()</a>, <a class="el" href="a11686.html#aaf99006cc33efe87eeb8411e6916ded6">opJoinRandomOrCreateRoom()</a>, <a class="el" href="a11686.html#a432926928eab7d79e3d362aa30dd2059">opJoinRandomRoom()</a>, <a class="el" href="a11686.html#afb426d3ebbe00e7bf2066dae48077e65">opLeaveRoom()</a>, <a class="el" href="a11758.html">MutableRoom</a>, Listener::joinRoomReturn() </dd></dl>

</div>
</div>
<a id="a432926928eab7d79e3d362aa30dd2059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432926928eab7d79e3d362aa30dd2059">&#9670;&nbsp;</a></span>opJoinRandomRoom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opJoinRandomRoom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a10770.html">Common::Hashtable</a> &amp;&#160;</td>
          <td class="paramname"><em>customRoomProperties</em> = <code><a class="el" href="a10770.html">Common::Hashtable</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>maxPlayers</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>matchmakingMode</em> = <code><a class="el" href="a10659.html#a86bac20ada21cfddcab4c885fa14b448">MatchmakingMode::FILL_ROOM</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>lobbyName</em> = <code><a class="el" href="a11510.html">Common::JString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>lobbyType</em> = <code><a class="el" href="a10658.html#a30c451d8c36cb067661cbe71e62eb2d6">LobbyType::DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>sqlLobbyFilter</em> = <code><a class="el" href="a11510.html">Common::JString</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11510.html">Common::JString</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expectedUsers</em> = <code><a class="el" href="a10810.html">Common::JVector</a>&lt;<a class="el" href="a11510.html">Common::JString</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Joins a random game room.</p>
<p>This function sends a request to the server to join a random game room. If it returns true, then Listener::joinRandomRoomReturn() gets called when the operation has been finished. </p><dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="a11686.html">Client</a> instance can only be inside one room at a time. Therefor this operation will fail and return false, if the client is already inside another game room. Any lobby the client currently resides in will implicitly be left when entering a game room. </dd>
<dd>
If no rooms are fitting or available (all full, closed or not visible), then this operation will fail and Listener::joinRandomRoomReturn() will get get called with an error code. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">customRoomProperties</td><td>Used as a filter for matchmaking. The server only considers rooms for which all custom properties match the specified filters. Note that only those custom room properties that have been specified for listing in the lobby will be used for matchmaking, so a rooms custom property can only match a specified filter if it got specified in the list of properties to show in the lobby. All values must be exact matches. </td></tr>
    <tr><td class="paramname">maxPlayers</td><td>Must match the value of a rooms maxPlayers property for that room to be considered for matchmaking. </td></tr>
    <tr><td class="paramname">matchmakingMode</td><td>Needs to be one of the values in MatchMakingMode </td></tr>
    <tr><td class="paramname">lobbyName</td><td>The name of the lobby in which matchmaking should take place. Only rooms that are listed in that lobby will be considered for matchmaking. </td></tr>
    <tr><td class="paramname">lobbyType</td><td>The type of the lobby in which matchmaking should take place. Needs to be one of the values in <a class="el" href="a10658.html">LobbyType</a>. Note that a lobby with the same name, but a different type can not be considered for matchmaking, as a lobby name only needs to be unique among lobbies of the same type. </td></tr>
    <tr><td class="paramname">sqlLobbyFilter</td><td>Only used for <a class="el" href="a10658.html#ac886f0e0011a225062d0e23fc69627f4" title="This lobby type lists rooms like type DEFAULT but SQL-like &quot;where&quot; clauses for filtering can be used ...">LobbyType::SQL_LOBBY</a>. This allows 'bigger', 'less', 'or' and 'and' combinations for filtering against certain room properties. Up to 3 ';'-separated filters can be specified. The second filter will only be considered if no rooms could be found that match the first filter and the third filter will only be considered if no rooms could be found that match either the first or the second filter. </td></tr>
    <tr><td class="paramname">expectedUsers</td><td>Sets a list of user IDs for which the server should reserve slots. Those slots can't be taken by other players. This list will be merged with any previously set list of expected users for this room. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a6c13655f1d3fc2020769f49f038d5edf">opCreateRoom()</a>, <a class="el" href="a11686.html#af643e24fb61a69db1d57a7d94c229031">opJoinOrCreateRoom()</a>, <a class="el" href="a11686.html#aaf99006cc33efe87eeb8411e6916ded6">opJoinRandomOrCreateRoom()</a>, <a class="el" href="a11686.html#a0989c3b651e46f90873c05e46a86fdea">opJoinRoom()</a>, <a class="el" href="a11686.html#afb426d3ebbe00e7bf2066dae48077e65">opLeaveRoom()</a>, <a class="el" href="a11758.html">MutableRoom</a>, Listener::joinRandomRoomReturn(), <a href="https://doc.photonengine.com/en-us/realtime/current/reference/matchmaking-and-lobby">Matchmaking and Lobby</a> </dd></dl>

</div>
</div>
<a id="afb426d3ebbe00e7bf2066dae48077e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb426d3ebbe00e7bf2066dae48077e65">&#9670;&nbsp;</a></span>opLeaveRoom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opLeaveRoom </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>willComeBack</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sendAuthCookie</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Leaves the currently joined game room.</p>
<p>This function sends a request to the server to leave the currently joined game room. If it returns true, then Listener::leaveRoomReturn() gets called when the operation has successfully been finished. </p><dl class="section remark"><dt>Remarks</dt><dd>This operation will fail and return false if the client does not currently reside inside any game room. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">willComeBack</td><td>If this is set to 'true', then the player becomes inactive and the client could later rejoin the room as the very same player. 'false' means the player leaves the room for good. Note that the player only stays inactive for at maximum as many milliseconds as you have set the playerTtl to during room creation (see <a class="el" href="a11778.html#ac4ef38546f06519e58a906f810600ce5">RoomOptions::setPlayerTtl()</a>). The default is 'false'. </td></tr>
    <tr><td class="paramname">sendAuthCookie</td><td>Pass 'true' to set the sendAuthCookie web flag (please see <a href="https://doc.photonengine.com/en-us/realtime/current/reference/webhooks-v1-2">Webhooks v1.2</a> for further information). The default is 'false'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a6c13655f1d3fc2020769f49f038d5edf">opCreateRoom()</a>, <a class="el" href="a11686.html#af643e24fb61a69db1d57a7d94c229031">opJoinOrCreateRoom()</a>, <a class="el" href="a11686.html#a0989c3b651e46f90873c05e46a86fdea">opJoinRoom()</a>, <a class="el" href="a11686.html#a432926928eab7d79e3d362aa30dd2059">opJoinRandomRoom()</a>, <a class="el" href="a11758.html">MutableRoom</a>, <a class="el" href="a11778.html">RoomOptions</a>, Listener::leaveRoomReturn() </dd></dl>

</div>
</div>
<a id="acb771a6191f13ded249d55630481bf01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb771a6191f13ded249d55630481bf01">&#9670;&nbsp;</a></span>opRaiseEvent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Ftype &gt; bool opRaiseEvent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reliable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ftype &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>eventCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11770.html">RaiseEventOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="a11770.html">RaiseEventOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends in-game data to other players in the game, who will receive it in their Listener::customEventAction() callback.</p>
<p>The eventCode should be used to define the event's type and content respectively. The payload has to be one of the datatypes that are listed as supported for values at <a class="el" href="a12694.html">serializable datatypes</a>.</p>
<p>This function provides the option to raise events reliably or unreliably. While both result in ordered events, the ones that got sent with the latter option might get lost, causing gaps in the resulting event sequence. On the other hand, they cause less overhead and are optimal for data that is replaced soon.</p>
<p>Note: the value of the reliability option only takes effect when the ConnectionProtocol passed to <a class="el" href="a11686.html#a21ff127a42053e416b4150f8ade01db8">Client()</a> equals ConnectionProtocol::UDP (which is the default for most platforms) and the message is small enough to not get fragmented into several UDP packets (rule of thumb: you can safely assume that the message fits into a single UDP packet, when its payload size is below 1kb), otherwise the message gets sent reliably, even when the reliability option asks for sending it unreliably.</p>
<p>Sending is not done immediately, but in intervals of <a class="el" href="a11686.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> calls.</p>
<p>It is recommended to keep the payload as simple as possible, especially for events that get raised multiple times per second. This easily adds up to a huge amount of data otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Listener::customEventAction(), <a class="el" href="a12694.html">Table of Datatypes</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reliable</td><td>true = the operation will be sent reliably; false = no resend in case of packet loss - will be ignored, when not using ConnectionProtocol::UDP </td></tr>
    <tr><td class="paramname">parameters</td><td>the payload of the event to raise - has to be provided in the form of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> </td></tr>
    <tr><td class="paramname">eventCode</td><td>number for arbitrary classification of the type of the event (like '1' for position updates, '2' for chat messages, and so on). </td></tr>
    <tr><td class="paramname">options</td><td>see <a class="el" href="a11770.html">RaiseEventOptions</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ef2f3dc6081e148aaba4d0a51378c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef2f3dc6081e148aaba4d0a51378c42">&#9670;&nbsp;</a></span>opRaiseEvent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Ftype &gt; bool opRaiseEvent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reliable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ftype&#160;</td>
          <td class="paramname"><em>pParameterArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Common::Helpers::ArrayLengthType&lt; Ftype &gt;::type&#160;</td>
          <td class="paramname"><em>arrSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>eventCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11770.html">RaiseEventOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="a11770.html">RaiseEventOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reliable</td><td>true = operation will be sent reliably; false = no resend in case of packet loss - will be ignored, when not using UDP as protocol </td></tr>
    <tr><td class="paramname">pParameterArray</td><td>the payload array of the event to raise - has to be provided in the form of a 1D array of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> </td></tr>
    <tr><td class="paramname">arrSize</td><td>the number of elements in pParameterArray </td></tr>
    <tr><td class="paramname">eventCode</td><td>number for arbitrary classification of the type of event (like '1' for position updates, '2' for chat messages, and so on). </td></tr>
    <tr><td class="paramname">options</td><td>see <a class="el" href="a11770.html">RaiseEventOptions</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a31f8f26f095b3edac41de7554f769d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a31f8f26f095b3edac41de7554f769d">&#9670;&nbsp;</a></span>opRaiseEvent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Ftype &gt; bool opRaiseEvent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reliable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ftype&#160;</td>
          <td class="paramname"><em>pParameterArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>pArrSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>eventCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11770.html">RaiseEventOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="a11770.html">RaiseEventOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reliable</td><td>true = operation will be sent reliably; false = no resend in case of packet loss - will be ignored, when not using UDP as protocol </td></tr>
    <tr><td class="paramname">pParameterArray</td><td>the payload array of the event to raise - has to be provided in the form of an array of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> </td></tr>
    <tr><td class="paramname">pArrSizes</td><td>an array holding the number of elements for each dimension of pParameterArray </td></tr>
    <tr><td class="paramname">eventCode</td><td>number for arbitrary classification of the type of event (like '1' for position updates, '2' for chat messages, and so on). </td></tr>
    <tr><td class="paramname">options</td><td>see <a class="el" href="a11770.html">RaiseEventOptions</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62feeb633da4d11b9675dd0bfc41ecf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62feeb633da4d11b9675dd0bfc41ecf8">&#9670;&nbsp;</a></span>opFindFriends()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opFindFriends </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> *&#160;</td>
          <td class="paramname"><em>friendsToFind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>numFriendsToFind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requests the rooms and online states for the specified list of friends. All clients should set a unique UserID before connecting. The result can be accessed through <a class="el" href="a11686.html#ab3d297b0e3b0a3545d2c63e029bcf562">getFriendList()</a> after the corresponding call to Listener::onFindFriendsResponse() has been received.</p>
<p>This function can be called when the caller does not currently reside in a game room to find the rooms played by a selected list of users. The result can be accessed by a call to <a class="el" href="a11686.html#ab3d297b0e3b0a3545d2c63e029bcf562">getFriendList()</a> and is empty before the first response has arrived in Listener::onFindFriendsResponse(). <a class="el" href="a11686.html#af61b642c390d6448ad2fd30ce90f0c07">getFriendListAge()</a> can be used to retrieve the amount of milliseconds that have passed since the value that is returned by <a class="el" href="a11686.html#ab3d297b0e3b0a3545d2c63e029bcf562">getFriendList()</a> has been updated for the last time.</p>
<p>Users identify themselves by passing their UserIDs to <a class="el" href="a11682.html#a96a5e1af8e628bb8dda93ea99f08109b">AuthenticationValues::setUserID()</a>.</p>
<p>The list of userIDs must be fetched from some other source (not provided by <a class="el" href="a10635.html">Photon</a>). </p><dl class="section remark"><dt>Remarks</dt><dd>This operation will fail and return false if the client does currently reside inside a game room or if the result for a previous call to this function has not arrived yet. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">friendsToFind</td><td>An array of unique userIDs. </td></tr>
    <tr><td class="paramname">numFriendsToFind</td><td>The element count of friendsToFind. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#ab3d297b0e3b0a3545d2c63e029bcf562">getFriendList()</a>, <a class="el" href="a11686.html#af61b642c390d6448ad2fd30ce90f0c07">getFriendListAge()</a>, Listener::onFindFriendsResponse() </dd></dl>

</div>
</div>
<a id="a3978b53f44234df440d0096a45dba26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3978b53f44234df440d0096a45dba26a">&#9670;&nbsp;</a></span>opLobbyStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opLobbyStats </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; <a class="el" href="a11746.html">LoadBalancing::LobbyStatsRequest</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lobbiesToQuery</em> = <code><a class="el" href="a10810.html">Common::JVector</a>&lt;<a class="el" href="a11746.html">LoadBalancing::LobbyStatsRequest</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sends the specified list of <a class="el" href="a11746.html">LobbyStatsRequest</a> objects to the server. The corresponding list of <a class="el" href="a11750.html">LobbyStatsResponse</a> objects arrives in Listener::onLobbyStatsResponse().</p>
<p>This function can be called when the caller does not currently reside in a game room to retrieve statistics for various lobbies.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This operation will fail and return false if the client does currently reside inside a game room. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Pass 'true' for the 'autoLobbyStats' parameter of <a class="el" href="a11686.html#a21ff127a42053e416b4150f8ade01db8">Client()</a> to automatically receive regular stats updates for all lobbies in Listener::onLobbyStatsUpdate(). When doing so, it makes little sense to also additionally call this function. <a class="el" href="a11686.html#a3978b53f44234df440d0096a45dba26a">opLobbyStats()</a> should rather be used in combination with passing 'false' for the 'autoLobbyStats' parameter of <a class="el" href="a11686.html#a21ff127a42053e416b4150f8ade01db8">Client()</a> to achieve fine-grain control of when / how often and for which lobbies you want to retrieve a stats update. This can be useful to reduce traffic when you have lots of lobbies, but only rarely need stats updates for most of them. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lobbiesToQuery</td><td>A <a class="el" href="a10810.html">Common::JVector</a> containing a <a class="el" href="a11746.html">LobbyStatsRequest</a> instance for each lobby that should be queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a21ff127a42053e416b4150f8ade01db8">Client()</a>, Listener::onLobbyStatsResponse(), Listener::onLobbyStatsUpdate(), <a class="el" href="a11746.html">LobbyStatsRequest</a>, <a class="el" href="a11750.html">LobbyStatsResponse</a> </dd></dl>

</div>
</div>
<a id="a27a98d2df8a640be7b0bace79d417cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a98d2df8a640be7b0bace79d417cfe">&#9670;&nbsp;</a></span>opChangeGroups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opChangeGroups </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; nByte &gt; *&#160;</td>
          <td class="paramname"><em>pGroupsToRemove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; nByte &gt; *&#160;</td>
          <td class="paramname"><em>pGroupsToAdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the clients interest groups (for events inside of game rooms).</p>
<p>This function can be called from inside of a game room to change the list of interest groups inside that room to which the local client is subscribed to. For each <a class="el" href="a11686.html#acb771a6191f13ded249d55630481bf01">opRaiseEvent()</a> call one can specify the interest groups to which that event should be sent in the <a class="el" href="a11770.html">RaiseEventOptions</a>. When doing so, only clients that are subscribed to those interest groups will receive that event.</p>
<p>Note the difference between passing NULL and the address of an empty JVector instance:</p><ul>
<li>NULL won't add/remove any groups.</li>
<li>a JVector without any elements will add/remove all (existing) groups.</li>
</ul>
<p>First, removing groups is executed. This way, you could leave all groups and join only the ones provided.</p>
<p>Changes become active not immediately but when the server executes this operation (approximately <a class="el" href="a11686.html#a85101f9ea38bc642cb74ec4ae571b9fb">getRoundTripTime()</a>/2 milliseconds after the <a class="el" href="a11686.html">Client</a> has sent it).</p>
<dl class="section remark"><dt>Remarks</dt><dd>This operation will fail and return false if the client does not currently reside inside a game room. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGroupsToRemove</td><td>Groups to remove from interest. NULL will not remove any. An empty instance will remove all. </td></tr>
    <tr><td class="paramname">pGroupsToAdd</td><td>Groups to add to interest. NULL will not add any. An empty instance will add all existing groups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#acb771a6191f13ded249d55630481bf01">opRaiseEvent()</a>, RaiseEventOptions::setInterestGroups(), <a href="https://doc.photonengine.com/en-us/realtime/current/reference/interestgroups">Interestgroups</a> </dd></dl>

</div>
</div>
<a id="a7dc5264127448466bceed827db4729eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc5264127448466bceed827db4729eb">&#9670;&nbsp;</a></span>opCustomAuthenticationSendNextStepData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opCustomAuthenticationSendNextStepData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11682.html">AuthenticationValues</a> &amp;&#160;</td>
          <td class="paramname"><em>authenticationValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used in conjunction with Listener::onCustomAuthenticationIntermediateStep() to implement multi-leg custom authentication.</p>
<p>While normally custom authentication is single-legged, occasionally a certain service may require multi-leg authentication. This means that the client sends some authentication data to the server that you pass when calling <a class="el" href="a11686.html#a952bb842759dee3916ceade681783456">connect()</a> and the server does not respond with a final result (successful connect or failed connect attempt due to an authentication error), but with some intermediate result data that gets passed to your Listener::onCustomAuthenticationIntermediateStep() implementation and that is needed by your application to acquire the authentication data for the next step of the authentication process. You can then pass that next step data to this function to continue the authentication process that you have started with the <a class="el" href="a11686.html#a952bb842759dee3916ceade681783456">connect()</a> call.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This operation will fail and return false if the client is not currently expecting it to be called. A call by you is only expected after you have received a call to Listener::onCustomAuthenticationIntermediateStep() beforehand and only one call to this function is expected after each received call to Listener::onCustomAuthenticationIntermediateStep(). If a call is expected, then the connection flow pauses until this call has been made. No call to this function is ever expected if the custom authentication that you have set up is single-legged (which is by far more common) or if you have not set up any custom authentication at all, which means that this function will always fail in these scenarios. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">authenticationValues</td><td>An instance of class <a class="el" href="a11682.html">AuthenticationValues</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a952bb842759dee3916ceade681783456">connect()</a>, Listener::onCustomAuthenticationIntermediateStep(), <a class="el" href="a11682.html">AuthenticationValues</a> </dd></dl>

</div>
</div>
<a id="acae8e7cd169e4d6d85e5749d0f62cad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae8e7cd169e4d6d85e5749d0f62cad7">&#9670;&nbsp;</a></span>opWebRpc() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opWebRpc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>uriPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes <a class="el" href="a10635.html">Photon</a> call your custom web-service by path/name with the given parameters (converted into JSON).</p>
<p>A WebRPC calls a custom, http-based function on a server that you provide. The uriPath is relative to a "base path" which is configured on the server side. The sent parameters get converted to Json. Vice versa, the response of the web-service will be converted back, when it gets sent back to the <a class="el" href="a11686.html">Client</a>, where it arrives in Listener::webRpcReturn().</p>
<p>To use this feature, you have to setup your server:</p>
<p>For a <a class="el" href="a10635.html">Photon</a> Cloud application visit the Dashboard and setup "WebHooks". The BaseUrl is used for WebRPCs as well.</p>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Listener::webRpcReturn(), <a class="el" href="a12694.html">Table of Datatypes</a>, <a href="https://doc.photonengine.com/en-us/realtime/current/reference/webhooks">Webhooks</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uriPath</td><td>the URL path to call, relative to the baseUrl configured on <a class="el" href="a10635.html">Photon</a>'s server-side </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac196509a01a92eb7e1f81a893f09984d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac196509a01a92eb7e1f81a893f09984d">&#9670;&nbsp;</a></span>opWebRpc() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Ftype &gt; bool opWebRpc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>uriPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ftype &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sendAuthCookie</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uriPath</td><td>the URL path to call, relative to the baseUrl configured on <a class="el" href="a10635.html">Photon</a>'s server-side </td></tr>
    <tr><td class="paramname">parameters</td><td>the parameters to send to the web-service method - has to be provided in the form of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> </td></tr>
    <tr><td class="paramname">sendAuthCookie</td><td>defines if the authentication cookie gets sent to a WebHook (if setup) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa229894c29b022f28ef0a330cc9bb956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa229894c29b022f28ef0a330cc9bb956">&#9670;&nbsp;</a></span>opWebRpc() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Ftype &gt; bool opWebRpc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>uriPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ftype&#160;</td>
          <td class="paramname"><em>pParameterArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Common::Helpers::ArrayLengthType&lt; Ftype &gt;::type&#160;</td>
          <td class="paramname"><em>arrSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sendAuthCookie</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uriPath</td><td>the URL path to call, relative to the baseUrl configured on <a class="el" href="a10635.html">Photon</a>'s server-side </td></tr>
    <tr><td class="paramname">pParameterArray</td><td>the parameter array to send to the web-service method - has to be provided in the form of a 1D array of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> </td></tr>
    <tr><td class="paramname">arrSize</td><td>the number of elements in pParameterArray </td></tr>
    <tr><td class="paramname">sendAuthCookie</td><td>defines if the authentication cookie gets sent to a WebHook (if setup) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8635325563a2e3de8d4423f979a12e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8635325563a2e3de8d4423f979a12e80">&#9670;&nbsp;</a></span>opWebRpc() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Ftype &gt; bool opWebRpc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>uriPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ftype&#160;</td>
          <td class="paramname"><em>pParameterArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>pArrSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sendAuthCookie</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uriPath</td><td>the URL path to call, relative to the baseUrl configured on <a class="el" href="a10635.html">Photon</a>'s server-side </td></tr>
    <tr><td class="paramname">pParameterArray</td><td>the parameter array to send to the web-service method - has to be provided in the form of an array of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> </td></tr>
    <tr><td class="paramname">pArrSizes</td><td>an array holding the number of elements for each dimension of pParameterArray </td></tr>
    <tr><td class="paramname">sendAuthCookie</td><td>defines if the authentication cookie gets sent to a WebHook (if setup) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afea8af9445884b3603d7211c1cdc7588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea8af9445884b3603d7211c1cdc7588">&#9670;&nbsp;</a></span>opGetRoomList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opGetRoomList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>lobby</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>sqlLobbyFilter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a list of games matching a SQL-like where clause. </p><dl class="section remark"><dt>Remarks</dt><dd>This operation is only available for lobbies of type <a class="el" href="a10658.html#ac886f0e0011a225062d0e23fc69627f4" title="This lobby type lists rooms like type DEFAULT but SQL-like &quot;where&quot; clauses for filtering can be used ...">LobbyType::SQL_LOBBY</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lobby</td><td>The lobby to query. Has to be of type <a class="el" href="a10658.html#ac886f0e0011a225062d0e23fc69627f4" title="This lobby type lists rooms like type DEFAULT but SQL-like &quot;where&quot; clauses for filtering can be used ...">LobbyType::SQL_LOBBY</a>. </td></tr>
    <tr><td class="paramname">sqlLobbyFilter</td><td>The sql query statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://doc.photonengine.com/en-us/realtime/current/reference/matchmaking-and-lobby#sql_lobby_type">sql_lobby_type</a> </dd></dl>

</div>
</div>
<a id="a880c327774ab3184e50570a601739eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880c327774ab3184e50570a601739eef">&#9670;&nbsp;</a></span>selectRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool selectRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>selectedRegion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used in conjunction with Listener::onAvailableRegions() and RegionSelectionMode::SELECT to select a certain server region to connect to.</p>
<p>If you pass RegionSelectionMode::SELECT for parameter 'regionSelectionMode' to <a class="el" href="a11686.html#a21ff127a42053e416b4150f8ade01db8">Client()</a>, then the <a class="el" href="a11686.html">Client</a> does not automatically choose a server region to connect to on its own during the connection flow, but upon retrieving the list of available regions and the list of server addresses that can be used to ping those regions it passes those lists to your implementation of Listener::onAvailableRegions() and pauses the connection flow. You then need to choose one of the available regions and select it by passing its name to this function to continue the connection flow.</p>
<p>The list of available regions for <a class="el" href="a10635.html">Photon</a> Public Cloud is available at <a href="https://doc.photonengine.com/en-us/realtime/current/reference/regions">Regions</a>. However more regions might be added over time after you have released your application and the list of available regions might differ when your appID is associated with a dedicated Cloud or when you connect to a non-default name server address. Also a certain region might be temporarily unavailable for maintenance. Furthermore some regions might consist out of multiple different clusters, while others don't. Therefor you should always assure that the region name that you pass to this function actually matches one of the entries in the list of available regions. Also be prepared to select a fall back option in case that your preferred region is not available.</p>
<p>A typical list of available regions might look like this (more or less regions might be available and the order of the entries is undefined and might change without notice): "eu", "us", "usw", "cae", "asia", "jp", "au", "sa", "in", "kr"</p>
<p>When multiple clusters per region are set up for your appID for some regions, then the list might look like this: "eu/Default", "eu/Cluster2", "us/Default", "us/Cluster2", "usw", "cae", "asia", "jp", "au", "sa", "in", "kr"</p>
<p>Examples for valid strings to pass for the 'eu' region for parameter 'selectedRegion' with the above example lists (adapt accordingly for other regions): </p><ul>
<li>
"eu" - Valid when at least one cluster is available in region 'eu', selects the default cluster for that region. </li>
<li>
"eu/Default" - Only valid when a cluster with the exact name "Default" is available in region 'eu'. </li>
<li>
"eu/Cluster2" - Only valid when a cluster with the exact name "Cluster2" is available in region 'eu'. </li>
<li>
"eu/&amp;lowast;" - Only valid when at least 2 clusters are set up in region 'eu' of which at least one is available. The server randomly selects one of the available clusters in the specified region. This string is not contained in the list of available regions and must be constructed by your code when it is valid and when you intend to select a random cluster. </li>
</ul>
<p>In case of the server randomly selecting a cluster, parameter 'cluster' of Listener::connectReturn() contains the name of the cluster to which the client has connected. Otherwise that parameter is an empty string. </p><dl class="section remark"><dt>Remarks</dt><dd>This operation will fail and return false if 'regionSelectionMode' has not been set to RegionSelectionMode::SELECT upon construction of this class instance. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selectedRegion</td><td>Must be a valid region name that matches one of the entries in the list of available regions that got passed to Listener::onAvailableRegions() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a21ff127a42053e416b4150f8ade01db8">Client()</a>, <a class="el" href="a11686.html#a952bb842759dee3916ceade681783456">connect()</a>, Listener::onAvailableRegions() </dd></dl>

</div>
</div>
<a id="ae5d587503f4c9816c1cfd92c1d09d29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d587503f4c9816c1cfd92c1d09d29e">&#9670;&nbsp;</a></span>reconnectAndRejoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reconnectAndRejoin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reconnects to the server and rejoins the last previously joined room.</p>
<p>This function reconnects directly to the game server to which it has previously been connected to and sends a request to the server to join the last previously joined game room. If it returns true, then Listener::joinRoomReturn() gets called when the operation has been finished.</p>
<p>The usual requirements for a rejoin apply, meaning the room must still exist, the local player must have entered it before, but it must not have left it for good, but only have become inactive and the playerTTL for the local player in that room must not have run out yet, otherwise this operation will fail and Listener::joinRoomReturn() will get called with an error code. </p><dl class="section remark"><dt>Remarks</dt><dd>This function will fail and return false if no game room has been entered since the creation of the class instance or if the client is still/already in a connected state. </dd>
<dd>
<a class="el" href="a11686.html#ae5d587503f4c9816c1cfd92c1d09d29e">reconnectAndRejoin()</a> is quicker than the combination of <a class="el" href="a11686.html#a952bb842759dee3916ceade681783456">connect()</a> and <a class="el" href="a11686.html#a0989c3b651e46f90873c05e46a86fdea">opJoinRoom()</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be queued for sending to the server, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a952bb842759dee3916ceade681783456">connect()</a>, <a class="el" href="a11686.html#a0989c3b651e46f90873c05e46a86fdea">opJoinRoom()</a>, Listener::joinRoomReturn() </dd></dl>

</div>
</div>
<a id="a53309df76f7e0b3d7bf77414aef8750d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53309df76f7e0b3d7bf77414aef8750d">&#9670;&nbsp;</a></span>sendDirect() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Ftype &gt; bool sendDirect </td>
          <td>(</td>
          <td class="paramtype">const Ftype &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetPlayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fallbackRelay</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends in-game data to other players in the game, who will receive it in their Listener::onDirectMessage() callback. Data that gets sent with this function, gets sent over a direct peer to peer connection, when possible.</p>
<p>For the Photon clients to attempt to establish direct peer to peer connections to each other when entering a room you need set the the <a class="el" href="a10655.html">DirectMode</a> Option either to <a class="el" href="a10655.html#a26c9d78b11a8bd1ef9f12dd93f5429b7" title="The master client establishes a direct connection with every other client inside the room....">DirectMode::MASTER_TO_ALL</a> or to <a class="el" href="a10655.html#ad3ada93a6a53e60b55e3c36a88f54160" title="Each client establishes a direct connection with every other client inside the room.">DirectMode::ALL_TO_ALL</a> on the <a class="el" href="a11778.html">RoomOptions</a> instance that you provide on room creation. Only when a direct connection to a certain client exists, data can be exchanged with it directly. Otherwise this function either falls back to sending it through the Photon game server with <a class="el" href="a11686.html#acb771a6191f13ded249d55630481bf01">opRaiseEvent()</a>, or doesn't send it at all, depending on the value of the 'fallbackRelay' parameter. Data transfer on a direct p2p connection always happens unreliably over UDP even when a different connection protocol has been chosen for connections to the <a class="el" href="a10635.html">Photon</a> servers in the constructor of this class. However data transfer over the fall-back relay uses the protocol that has been selected for connections to the <a class="el" href="a10635.html">Photon</a> server when calling the constructor.</p>
<p>It is recommended to keep the payload as simple as possible, as the data is typically sent multiple times per second. This easily adds up to a huge amount of data otherwise. </p><dl class="section note"><dt>Note</dt><dd>A direct connection to a certain client is not guaranteed to exist, even when <a class="el" href="a11778.html#a5eef68390f6a6da9fe4a5b945338e8b9">RoomOptions::setDirectMode()</a> specifies that the Clients should attempt to establish it, as NAT punch-through does not have a 100% success rate. In the case that a direct message is preferable, but a relayed one would be acceptable when no direct connection exists, the 'fallbackRelay' option comes into play. </dd>
<dd>
Furthermore if a client looses its connection to Photon while other clients can still reach the server, then that client most likely lost its internet connection and direct messages won't reach it anymore either. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function provides a rather low-level raw UDP socket like way to send data. If you need any higher level functionality like reliable data delivery, support for bigger messages, message caching, interest groups or webforwarding, then please use <a class="el" href="a11686.html#acb771a6191f13ded249d55630481bf01">opRaiseEvent()</a> instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Listener::onDirectMessage(), <a class="el" href="a11686.html#acb771a6191f13ded249d55630481bf01">opRaiseEvent()</a>, <a class="el" href="a10655.html">DirectMode</a>, <a class="el" href="a11778.html#a78527fe20572c13a8c97a39d3caa5d1e">RoomOptions::getDirectMode()</a>, <a class="el" href="a11778.html#a5eef68390f6a6da9fe4a5b945338e8b9">RoomOptions::setDirectMode()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>the data to send - has to be provided in the form of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> - must be less than 1200 bytes </td></tr>
    <tr><td class="paramname">targetPlayer</td><td>the player number of the intended receiver of the message - must be the number of another active player inside the same room as the sender </td></tr>
    <tr><td class="paramname">fallbackRelay</td><td>true if the Photon game server that hosts the room should be used as a fallback relay (by an automatic call to <a class="el" href="a11686.html#acb771a6191f13ded249d55630481bf01">opRaiseEvent()</a>) when no direct connection to the other client exists, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be sent (this does not guarantee that it will be received), false otherwise. </dd></dl>

</div>
</div>
<a id="a98b89fe6afd658b684d67d77d0248769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b89fe6afd658b684d67d77d0248769">&#9670;&nbsp;</a></span>sendDirect() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Ftype &gt; bool sendDirect </td>
          <td>(</td>
          <td class="paramtype">const Ftype&#160;</td>
          <td class="paramname"><em>pParameterArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Common::Helpers::ArrayLengthType&lt; Ftype &gt;::type&#160;</td>
          <td class="paramname"><em>arrSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetPlayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fallbackRelay</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pParameterArray</td><td>the data to send - has to be provided in the form of a 1D array of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> - must be less than 1200 bytes </td></tr>
    <tr><td class="paramname">arrSize</td><td>the number of elements in pParameterArray </td></tr>
    <tr><td class="paramname">targetPlayer</td><td>the player number of the intended receiver of the message - must be the number of another active player inside the same room as the sender </td></tr>
    <tr><td class="paramname">fallbackRelay</td><td>true if the Photon game server that hosts the room should be used as a fallback relay (by an automatic call to <a class="el" href="a11686.html#acb771a6191f13ded249d55630481bf01">opRaiseEvent()</a>) for all specified receivers to which no direct connection exists, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be sent (this does not guarantee that it will be received), false otherwise. </dd></dl>

</div>
</div>
<a id="ac9e6e1b11758f9f29c0a2dbedfcb0e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e6e1b11758f9f29c0a2dbedfcb0e77">&#9670;&nbsp;</a></span>sendDirect() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Ftype &gt; bool sendDirect </td>
          <td>(</td>
          <td class="paramtype">const Ftype&#160;</td>
          <td class="paramname"><em>pParameterArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>pArrSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>targetPlayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fallbackRelay</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pParameterArray</td><td>the the data to send - has to be provided in the form of an array of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> - must be less than 1200 bytes </td></tr>
    <tr><td class="paramname">pArrSizes</td><td>an array holding the number of elements for each dimension of pParameterArray </td></tr>
    <tr><td class="paramname">targetPlayer</td><td>the player number of the intended receiver of the message - must be the number of another active player inside the same room as the sender </td></tr>
    <tr><td class="paramname">fallbackRelay</td><td>true if the Photon game server that hosts the room should be used as a fallback relay (by an automatic call to <a class="el" href="a11686.html#acb771a6191f13ded249d55630481bf01">opRaiseEvent()</a>) for all specified receivers to which no direct connection exists, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if the request could successfully be sent (this does not guarantee that it will be received), false otherwise. </dd></dl>

</div>
</div>
<a id="a9ffe16369e2ae560693625164affafb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ffe16369e2ae560693625164affafb3">&#9670;&nbsp;</a></span>sendDirect() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Ftype &gt; int sendDirect </td>
          <td>(</td>
          <td class="paramtype">const Ftype &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>targetPlayers</em> = <code><a class="el" href="a10810.html">Common::JVector</a>&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fallbackRelay</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>the data to send - has to be provided in the form of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> - must be less than 1200 bytes </td></tr>
    <tr><td class="paramname">targetPlayers</td><td>the player numbers of the intended receivers of the message - must be the numbers of other active players inside the same room as the sender; an empty JVector means 'send to everyone inside the room, except the sender itself' </td></tr>
    <tr><td class="paramname">fallbackRelay</td><td>true if the Photon game server that hosts the room should be used as a fallback relay (by an automatic call to <a class="el" href="a11686.html#acb771a6191f13ded249d55630481bf01">opRaiseEvent()</a>) for all specified receivers to which no direct connection exists, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of target players, for which the request could successfully be sent (this does not guarantee that it will be received). </dd></dl>

</div>
</div>
<a id="a23b3d7d2ef7ffb008a71ab94e1c535a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b3d7d2ef7ffb008a71ab94e1c535a3">&#9670;&nbsp;</a></span>sendDirect() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Ftype &gt; int sendDirect </td>
          <td>(</td>
          <td class="paramtype">const Ftype&#160;</td>
          <td class="paramname"><em>pParameterArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Common::Helpers::ArrayLengthType&lt; Ftype &gt;::type&#160;</td>
          <td class="paramname"><em>arrSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>targetPlayers</em> = <code><a class="el" href="a10810.html">Common::JVector</a>&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fallbackRelay</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pParameterArray</td><td>the data to send - has to be provided in the form of a 1D array of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> - must be less than 1200 bytes </td></tr>
    <tr><td class="paramname">arrSize</td><td>the number of elements in pParameterArray </td></tr>
    <tr><td class="paramname">targetPlayers</td><td>the player numbers of the intended receivers of the message - must be the numbers of other active players inside the same room as the sender; an empty JVector means 'send to everyone inside the room, except the sender itself' </td></tr>
    <tr><td class="paramname">fallbackRelay</td><td>true if the Photon game server that hosts the room should be used as a fallback relay (by an automatic call to <a class="el" href="a11686.html#acb771a6191f13ded249d55630481bf01">opRaiseEvent()</a>) for all specified receivers to which no direct connection exists, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of target players, for which the request could successfully be sent (this does not guarantee that it will be received). </dd></dl>

</div>
</div>
<a id="add92be9d33127b06ed4a73df31f103c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add92be9d33127b06ed4a73df31f103c9">&#9670;&nbsp;</a></span>sendDirect() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Ftype &gt; int sendDirect </td>
          <td>(</td>
          <td class="paramtype">const Ftype&#160;</td>
          <td class="paramname"><em>pParameterArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>pArrSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>targetPlayers</em> = <code><a class="el" href="a10810.html">Common::JVector</a>&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fallbackRelay</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pParameterArray</td><td>the data to send - has to be provided in the form of an array of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> - must be less than 1200 bytes </td></tr>
    <tr><td class="paramname">pArrSizes</td><td>an array holding the number of elements for each dimension of pParameterArray </td></tr>
    <tr><td class="paramname">targetPlayers</td><td>the player numbers of the intended receivers of the message - must be the numbers of other active players inside the same room as the sender; an empty JVector means 'send to everyone inside the room, except the sender itself' </td></tr>
    <tr><td class="paramname">fallbackRelay</td><td>true if the Photon game server that hosts the room should be used as a fallback relay (by an automatic call to <a class="el" href="a11686.html#acb771a6191f13ded249d55630481bf01">opRaiseEvent()</a>) for all specified receivers to which no direct connection exists, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of target players, for which the request could successfully be sent (this does not guarantee that it will be received). </dd></dl>

</div>
</div>
<a id="a284335c6f6ff72286cb69bc396f03a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284335c6f6ff72286cb69bc396f03a20">&#9670;&nbsp;</a></span>sendDirect() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sendDirect </td>
          <td>(</td>
          <td class="paramtype">const nByte *&#160;</td>
          <td class="paramname"><em>pParameterArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pParameterArray</td><td>the data to send - has to be provided in the form of a 1D array of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> - must be less than 1200 bytes </td></tr>
    <tr><td class="paramname">arrSize</td><td>the number of elements in pParameterArray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of target players, for which the request could successfully be sent (this does not guarantee that it will be received). </dd></dl>

</div>
</div>
<a id="aa2f22f30fb0f0ebf638ef1ad46024bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f22f30fb0f0ebf638ef1ad46024bc2">&#9670;&nbsp;</a></span>sendDirect() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sendDirect </td>
          <td>(</td>
          <td class="paramtype">nByte *&#160;</td>
          <td class="paramname"><em>pParameterArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arrSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pParameterArray</td><td>the data to send - has to be provided in the form of a 1D array of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> - must be less than 1200 bytes </td></tr>
    <tr><td class="paramname">arrSize</td><td>the number of elements in pParameterArray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of target players, for which the request could successfully be sent (this does not guarantee that it will be received). </dd></dl>

</div>
</div>
<a id="a900f6a3f619a74f8bc341f59c69b4380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900f6a3f619a74f8bc341f59c69b4380">&#9670;&nbsp;</a></span>getServerTimeOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getServerTimeOffset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the difference between the local uptime and the Photon Server's system time in ms.</dd></dl>
<p>In real-time games it's often useful to relate game events to a global common timeline, that's valid for all players and independent from derivations throughout the clients' system times. The Photon Server's System Time can serve as this reference time. The serverTimeOffset represents the difference between the client's local system time and the Photon server's system time.</p>
<p>ServerTime = serverTimeOffset + GETTIMEMS()</p>
<p>The serverTimeOffset is fetched shortly after connect by <a class="el" href="a10635.html">Photon</a>. Use GETTIMEMS() to get your local time in ms. You can let Photon refetch the offset by calling <a class="el" href="a11686.html#ab2e6e2243583f7cf42b8123e068302e9">fetchServerTimestamp()</a>. The ServerTimeOffset will be 0 until shortly after initial connect. </p>

</div>
</div>
<a id="aa108814e82124d5f4af471ea4ffb610a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa108814e82124d5f4af471ea4ffb610a">&#9670;&nbsp;</a></span>getServerTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getServerTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the Photon Server's system time ins ms.</dd></dl>
<p>see <a class="el" href="a11686.html#a900f6a3f619a74f8bc341f59c69b4380">getServerTimeOffset()</a> </p>

</div>
</div>
<a id="ad4bf9454763f5626f1192700072c174d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bf9454763f5626f1192700072c174d">&#9670;&nbsp;</a></span>getBytesOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getBytesOut </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the total number of outgoing bytes transmitted by this PhotonPeer object. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a8635d0982d8288ca623c8ff69c057c99">getBytesIn()</a> </dd></dl>

</div>
</div>
<a id="a8635d0982d8288ca623c8ff69c057c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8635d0982d8288ca623c8ff69c057c99">&#9670;&nbsp;</a></span>getBytesIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getBytesIn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the total number of incoming bytes received by this PhotonPeer object. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#ad4bf9454763f5626f1192700072c174d">getBytesOut()</a> </dd></dl>

</div>
</div>
<a id="a263a49684b3758d495c41872d56d0957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263a49684b3758d495c41872d56d0957">&#9670;&nbsp;</a></span>getByteCountCurrentDispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getByteCountCurrentDispatch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the size of the dispatched event or operation-result in bytes. This value is set before onEvent() or onOperationResponse() is called (within <a class="el" href="a11686.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a>). Get this value directly in onEvent() or onOperationResponse(). </dd></dl>

</div>
</div>
<a id="a6ee1554a47db34977491552bcd256d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee1554a47db34977491552bcd256d6c">&#9670;&nbsp;</a></span>getByteCountLastOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getByteCountLastOperation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the size of the last serialized operation call in bytes. The value includes all headers for this single operation but excludes those of UDP, Enet Package Headers and TCP. Get this value immediately after calling an operation. </dd></dl>

</div>
</div>
<a id="ac8e39d83514f8803df537245cf23db14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e39d83514f8803df537245cf23db14">&#9670;&nbsp;</a></span>getSentCountAllowance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getSentCountAllowance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the number of resend retries before a peer is considered lost/disconnected.</dd></dl>
<p>This is udp specific and will always return 0 for other protocols. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a9a6f199c62967e857482a2e6ae0cd95d">setSentCountAllowance()</a> <a class="el" href="a11686.html#acdda1b98b605e108ac6950d9c2d8ff3b">getDisconnectTimeout()</a> <a class="el" href="a11686.html#a9f9e8b780e386121f1b33b3f1c95c123">setDisconnectTimeout()</a> </dd></dl>

</div>
</div>
<a id="a9a6f199c62967e857482a2e6ae0cd95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6f199c62967e857482a2e6ae0cd95d">&#9670;&nbsp;</a></span>setSentCountAllowance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSentCountAllowance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sentCountAllowance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Sets the number of re-send retries before a peer is considered lost/disconnected.</p>
<p>This is udp specific and will do nothing at all for other protocols. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sentCountAllowance</td><td>the new number of re/-send retries before a peer is considered lost/disconnected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#ac8e39d83514f8803df537245cf23db14">getSentCountAllowance()</a> <a class="el" href="a11686.html#acdda1b98b605e108ac6950d9c2d8ff3b">getDisconnectTimeout()</a> <a class="el" href="a11686.html#a9f9e8b780e386121f1b33b3f1c95c123">setDisconnectTimeout()</a> </dd></dl>

</div>
</div>
<a id="af40fc8e3f6004b9cbd6f99290e6aa4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40fc8e3f6004b9cbd6f99290e6aa4d8">&#9670;&nbsp;</a></span>getTimePingInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getTimePingInterval </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the time threshold in milliseconds since the last reliable command, before a ping will be sent. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#aa7f6b25436dc87fe34f53c2eec8df65a">setTimePingInterval()</a> </dd></dl>

</div>
</div>
<a id="aa7f6b25436dc87fe34f53c2eec8df65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f6b25436dc87fe34f53c2eec8df65a">&#9670;&nbsp;</a></span>setTimePingInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setTimePingInterval </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timePingInterval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Sets the time threshold in milliseconds since the last reliable command, before a ping will be sent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timePingInterval</td><td>time threshold in milliseconds since the last reliable command, before a ping will be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#af40fc8e3f6004b9cbd6f99290e6aa4d8">getTimePingInterval()</a> </dd></dl>

</div>
</div>
<a id="a85101f9ea38bc642cb74ec4ae571b9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85101f9ea38bc642cb74ec4ae571b9fb">&#9670;&nbsp;</a></span>getRoundTripTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getRoundTripTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the time in milliseconds until a reliable command is acknowledged by the server.</dd></dl>
<p>This is, what is commonly called a ping time or just a ping. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#ace25d38b4d458e3dfb0b670ecd317682">getRoundTripTimeVariance()</a> </dd></dl>

</div>
</div>
<a id="ace25d38b4d458e3dfb0b670ecd317682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace25d38b4d458e3dfb0b670ecd317682">&#9670;&nbsp;</a></span>getRoundTripTimeVariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getRoundTripTimeVariance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the variance of the roundtrip time in milliseconds. Gives a hint about how much the net latency is varying. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a85101f9ea38bc642cb74ec4ae571b9fb">getRoundTripTime()</a> </dd></dl>

</div>
</div>
<a id="aea076259cd369fb751e50467adea2361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea076259cd369fb751e50467adea2361">&#9670;&nbsp;</a></span>getTimestampOfLastSocketReceive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getTimestampOfLastSocketReceive </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>timestamp of the last time anything (!) was received from the server (including low level Ping and ACKs but also events and operation-returns). This is not the time when something was dispatched. </dd></dl>

</div>
</div>
<a id="acee10207cc62f0fa06f3b8853621295a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee10207cc62f0fa06f3b8853621295a">&#9670;&nbsp;</a></span>getDebugOutputLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getDebugOutputLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Returns the current level of debug information that's passed on to <a class="el" href="a10714.html#a6fcf1232530518193479d1c38c916843">BaseListener::debugReturn()</a>. </p><dl class="section return"><dt>Returns</dt><dd>one of the values in DebugLevel </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a163e299695ce92d2f02eb4b78b29ab2b">setDebugOutputLevel()</a> </dd></dl>

</div>
</div>
<a id="a163e299695ce92d2f02eb4b78b29ab2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163e299695ce92d2f02eb4b78b29ab2b">&#9670;&nbsp;</a></span>setDebugOutputLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setDebugOutputLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>debugLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Sets the current level of debug information that's passed on to <a class="el" href="a10714.html#a6fcf1232530518193479d1c38c916843">BaseListener::debugReturn()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">debugLevel</td><td>one of the values in DebugLevel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the new debug level has been set correctly, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#acee10207cc62f0fa06f3b8853621295a">getDebugOutputLevel()</a> </dd></dl>

</div>
</div>
<a id="a61033342848847f071fa6d35aff19f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61033342848847f071fa6d35aff19f37">&#9670;&nbsp;</a></span>getLogFormatOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a11522.html">LogFormatOptions</a> &amp; getLogFormatOptions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the LogFormatOptions that are used by this instance. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setFormatOptions() </dd></dl>

</div>
</div>
<a id="ae5f7c93e1c773e9369da96bb1e7dd2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f7c93e1c773e9369da96bb1e7dd2e3">&#9670;&nbsp;</a></span>setLogFormatOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setLogFormatOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11522.html">Common::LogFormatOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>formatOptions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Sets the log format options to the supplied value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formatOptions</td><td>the new value to which the log format options will be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>getFormatOptions() </dd></dl>

</div>
</div>
<a id="a7493c7adc48661bc30026674de31d561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7493c7adc48661bc30026674de31d561">&#9670;&nbsp;</a></span>getIncomingReliableCommandsCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getIncomingReliableCommandsCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the total number of reliable commands currently waiting in the incoming queues of all channels or -1 if not connected. </dd></dl>

</div>
</div>
<a id="a57ffbf998c2d43f7261e31a3858e3e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ffbf998c2d43f7261e31a3858e3e18">&#9670;&nbsp;</a></span>getPeerID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short getPeerID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>this peer's ID as assigned by the server. Will be -1, if not connected. </dd></dl>

</div>
</div>
<a id="acdda1b98b605e108ac6950d9c2d8ff3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdda1b98b605e108ac6950d9c2d8ff3b">&#9670;&nbsp;</a></span>getDisconnectTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getDisconnectTimeout </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the maximum time interval in milliseconds for doing resend retries before a peer is considered lost/disconnected. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a9f9e8b780e386121f1b33b3f1c95c123">setDisconnectTimeout()</a> <a class="el" href="a11686.html#ac8e39d83514f8803df537245cf23db14">getSentCountAllowance()</a> <a class="el" href="a11686.html#a9a6f199c62967e857482a2e6ae0cd95d">setSentCountAllowance()</a> </dd></dl>

</div>
</div>
<a id="a9f9e8b780e386121f1b33b3f1c95c123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9e8b780e386121f1b33b3f1c95c123">&#9670;&nbsp;</a></span>setDisconnectTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDisconnectTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>disconnectTimeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Sets the maximum time ins milliseconds for making re-send retries before a peer is considered lost/disconnected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disconnectTimeout</td><td>resend max time in ms before a peer is considered lost/disconnected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#acdda1b98b605e108ac6950d9c2d8ff3b">getDisconnectTimeout()</a> <a class="el" href="a11686.html#ac8e39d83514f8803df537245cf23db14">getSentCountAllowance()</a> <a class="el" href="a11686.html#a9a6f199c62967e857482a2e6ae0cd95d">setSentCountAllowance()</a> </dd></dl>

</div>
</div>
<a id="a82ca352fb9c22793bf6a1f534fd9eedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ca352fb9c22793bf6a1f534fd9eedb">&#9670;&nbsp;</a></span>getQueuedIncomingCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getQueuedIncomingCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the number of queued incoming commands in all channels or -1 if not connected </dd></dl>

</div>
</div>
<a id="a3173bc58e2727d71e30e6a44279aabcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3173bc58e2727d71e30e6a44279aabcd">&#9670;&nbsp;</a></span>getQueuedOutgoingCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getQueuedOutgoingCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the number of queued outgoing commands in all channels or -1 if not connected </dd></dl>

</div>
</div>
<a id="a128dedaab588e53ded9fd9b7708e140b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128dedaab588e53ded9fd9b7708e140b">&#9670;&nbsp;</a></span>getIsPayloadEncryptionAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getIsPayloadEncryptionAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>this peer's payload encryption availability status. True if payload encryption is available, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#abeb9753eb4af1ebe91f31d0015ee20f4">getIsEncryptionAvailable()</a>, establishEncryption(), initUserDataEncryption() </dd></dl>

</div>
</div>
<a id="abeb9753eb4af1ebe91f31d0015ee20f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb9753eb4af1ebe91f31d0015ee20f4">&#9670;&nbsp;</a></span>getIsEncryptionAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getIsEncryptionAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>this peer's encryption availability status. True if either payload encryption is available or if the connection protocol is UDP and UDP encryption is available or if the connection protocol is already secure on its own, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a128dedaab588e53ded9fd9b7708e140b">getIsPayloadEncryptionAvailable()</a>, establishEncryption(), initUserDataEncryption(), initUDPEncryption() </dd></dl>

</div>
</div>
<a id="aedf52333d72638f95904828d4abebdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf52333d72638f95904828d4abebdc4">&#9670;&nbsp;</a></span>getResentReliableCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getResentReliableCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the count of commands that got repeated (due to local repeat-timing before an ACK was received). </dd></dl>

</div>
</div>
<a id="a8e0ae75e5cbd27385fac17357795d239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0ae75e5cbd27385fac17357795d239">&#9670;&nbsp;</a></span>getLimitOfUnreliableCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getLimitOfUnreliableCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the limit for the queue of received unreliable commands. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a675a14def7ed1f13d8851c2c509fda44">setLimitOfUnreliableCommands()</a> </dd></dl>

</div>
</div>
<a id="a675a14def7ed1f13d8851c2c509fda44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675a14def7ed1f13d8851c2c509fda44">&#9670;&nbsp;</a></span>setLimitOfUnreliableCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setLimitOfUnreliableCommands </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Sets the limit for the queue of received unreliable commands. This works only in UDP. This limit is applied when you call dispatchIncomingCommands. If this client (already) received more than this limit, it will throw away the older ones instead of dispatching them. This can produce bigger gaps for unreliable commands but your client catches up faster. This can be useful when the client couldn't dispatch anything for some time (cause it was in a room but loading a level). If set to 20, the incoming unreliable queues are truncated to 20. If 0, all received unreliable commands will be dispatched. This is a "per channel" value, so each channel can hold commands up to specified limit. This value interacts with <a class="el" href="a11686.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a>: If that is called less often, more commands get skipped. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a8e0ae75e5cbd27385fac17357795d239">getLimitOfUnreliableCommands()</a> </dd></dl>

</div>
</div>
<a id="aacd6583f9b6732f5217b69de3016ef8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd6583f9b6732f5217b69de3016ef8d">&#9670;&nbsp;</a></span>getCRCEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getCRCEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>true if CRC enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a86720f73f3549fe7cec3c48aaaed2dea">setCRCEnabled</a> </dd></dl>

</div>
</div>
<a id="a86720f73f3549fe7cec3c48aaaed2dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86720f73f3549fe7cec3c48aaaed2dea">&#9670;&nbsp;</a></span>setCRCEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setCRCEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>crcEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Enables or disables CRC. While not connected, this controls if the next connection(s) should use a per-package CRC checksum. If the client is in another state than 'connected', then this function has no effect except for logging an error.</p>
<p>While turned on, the client and server will add a CRC checksum to every sent package. The checksum enables both sides to detect and ignore packages that were corrupted during transfer. Corrupted packages have the same impact as lost packages: They require a re-send, adding a delay and could lead to timeouts. Building the checksum has a low processing overhead but increases integrity of sent and received data. Packages discarded due to failed CRC checks are counted in PhotonPeer.PacketLossByCRC. </p><dl class="section note"><dt>Note</dt><dd>This only has effect for UDP connections. </dd>
<dd>
This does not have any effect for connections that use UDP datagram encryption (which always use a built-in checksum). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#aacd6583f9b6732f5217b69de3016ef8d">getCRCEnabled</a> </dd></dl>

</div>
</div>
<a id="ac21ce2fab19a7f89371b55b80e9a6104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21ce2fab19a7f89371b55b80e9a6104">&#9670;&nbsp;</a></span>getPacketLossByCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getPacketLossByCRC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the count of packages dropped due to failed CRC checks for this connection. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a86720f73f3549fe7cec3c48aaaed2dea">setCRCEnabled</a> </dd></dl>

</div>
</div>
<a id="a63818ef2534cb686799ba4b8089d87b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63818ef2534cb686799ba4b8089d87b1">&#9670;&nbsp;</a></span>getTrafficStatsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getTrafficStatsEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>true if traffic statistics of a peer are enabled. Default trafficStatsEnabled: false (disabled). </dd></dl>

</div>
</div>
<a id="a084574cf6d7c3f916dff4b6c23070ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084574cf6d7c3f916dff4b6c23070ade">&#9670;&nbsp;</a></span>setTrafficStatsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setTrafficStatsEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trafficStatsEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Enables or disables the traffic statistics of a peer. Default trafficStatsEnabled: false (disabled). </p>

</div>
</div>
<a id="aa9fd6df74699a45931166b13b8473969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fd6df74699a45931166b13b8473969">&#9670;&nbsp;</a></span>getTrafficStatsElapsedMs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getTrafficStatsElapsedMs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the count of milliseconds the stats are enabled for tracking. </dd></dl>

</div>
</div>
<a id="a330891f9c5b4bdb083ee510e5dbbe0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330891f9c5b4bdb083ee510e5dbbe0ea">&#9670;&nbsp;</a></span>getTrafficStatsIncoming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a11674.html">Photon::TrafficStats</a> &amp; getTrafficStatsIncoming </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the byte-count of incoming "low level" messages, which are either Enet Commands or TCP Messages. These include all headers, except those of the underlying internet protocol UDP or TCP. </dd></dl>

</div>
</div>
<a id="a19f3cf485ad2516b5f4a65ddf74914ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f3cf485ad2516b5f4a65ddf74914ad">&#9670;&nbsp;</a></span>getTrafficStatsOutgoing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a11674.html">Photon::TrafficStats</a> &amp; getTrafficStatsOutgoing </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the byte-count of outgoing "low level" messages, which are either Enet Commands or TCP Messages. These include all headers, except those of the underlying internet protocol UDP or TCP. </dd></dl>

</div>
</div>
<a id="a23b8575849c266412044dfe7666ff395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b8575849c266412044dfe7666ff395">&#9670;&nbsp;</a></span>getTrafficStatsGameLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a11678.html">Photon::TrafficStatsGameLevel</a> &amp; getTrafficStatsGameLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>a statistic of incoming and outgoing traffic, split by operation, operation-result and event. Operations are outgoing traffic, results and events are incoming. Includes the per-command header sizes (UDP: Enet Command Header or TCP: Message Header). </dd></dl>

</div>
</div>
<a id="adb2b890f4b3dd79360358b3afaffd9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2b890f4b3dd79360358b3afaffd9e8">&#9670;&nbsp;</a></span>getQuickResendAttempts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nByte getQuickResendAttempts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the number of resend attempts for a reliable command that are done in quick succession (after RoundTripTime+4*RoundTripTimeVariance). </dd></dl>

</div>
</div>
<a id="a2a43056816067b306fc0feb54bcd97f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a43056816067b306fc0feb54bcd97f5">&#9670;&nbsp;</a></span>setQuickResendAttempts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setQuickResendAttempts </td>
          <td>(</td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>quickResendAttempts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Sets the number of resend attempts for a reliable command can be done in quick succession (after RoundTripTime+4*RoundTripTimeVariance). </p><dl class="section remark"><dt>Remarks</dt><dd>The default value is 0. Any later resend attempt will then double the time before the next resend takes place. The max value is 4. Make sure to set SentCountAllowance to a slightly higher value, as more repeats will get done. </dd></dl>

</div>
</div>
<a id="a1b8dacd122e7d5ebaeee1f309a2858b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8dacd122e7d5ebaeee1f309a2858b8">&#9670;&nbsp;</a></span>getChannelCountUserChannels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nByte getChannelCountUserChannels </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>The IDs from 0 to <a class="el" href="a11686.html#a1b8dacd122e7d5ebaeee1f309a2858b8">getChannelCountUserChannels()</a>-1 can be passed as channelID to operations that offer this parameter. </p><dl class="section return"><dt>Returns</dt><dd>the number of different channels that are available for sending operations on. </dd></dl>

</div>
</div>
<a id="a10359924120048ca6281db6ed9dda97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10359924120048ca6281db6ed9dda97d">&#9670;&nbsp;</a></span>getPeerCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short getPeerCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the count of peers, which have been initialized since the start of the application. Interesting mainly for debugging purposes. </dd></dl>

</div>
</div>
<a id="a7269d12f6ec7a7f81d0c7d8207c34d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7269d12f6ec7a7f81d0c7d8207c34d15">&#9670;&nbsp;</a></span>getState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Current state this <a class="el" href="a11686.html">Client</a> instance is in. Be Careful: several states are "transitions" that lead to other states.</p>
<dl class="section note"><dt>Note</dt><dd>This is publicly available purely for informational purposes (i.e. when debugging) and your logic should not rely on certain state changes, but should instead wait for the dedicated callbacks.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>one of the values defined in <a class="el" href="a10660.html">PeerStates</a> </dd></dl>

</div>
</div>
<a id="a44517d39bb964fc887b0a7a087e47e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44517d39bb964fc887b0a7a087e47e5b">&#9670;&nbsp;</a></span>getMasterserverAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a11510.html">JString</a> &amp; getMasterserverAddress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the address of the master server to which the client is connected when it is not inside a game room. </dd></dl>

</div>
</div>
<a id="af307d50f8aff62df93e60770d1ac9128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af307d50f8aff62df93e60770d1ac9128">&#9670;&nbsp;</a></span>getCountPlayersIngame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getCountPlayersIngame </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the count of players that are currently participating in games on game servers that are in the same cluster (game servers assigned to the same master server) as the local client. Each <a class="el" href="a10635.html">Photon</a> Cloud region consists of at least one, but potentially multiple separate clusters. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This value is only getting updated when the client is on the master server. </dd></dl>

</div>
</div>
<a id="a1358d18cbbde3bb42ff31e6f09eb8304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1358d18cbbde3bb42ff31e6f09eb8304">&#9670;&nbsp;</a></span>getCountGamesRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getCountGamesRunning </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the count of rooms that are currently existing on game servers in the same cluster (game servers assigned to the same master server) as the one the local client is connected to. Each <a class="el" href="a10635.html">Photon</a> Cloud region consists of at least one, but potentially multiple separate clusters. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This value is only getting updated when the client is on the master server. </dd></dl>

</div>
</div>
<a id="a4d21306efa52d7da26a6aed0996cb1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d21306efa52d7da26a6aed0996cb1ab">&#9670;&nbsp;</a></span>getCountPlayersOnline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getCountPlayersOnline </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total count of players that are currently connected to the same cluster (clients that are connected to the same master server or to a game server that is assigned to the same master server) as the local client. Each <a class="el" href="a10635.html">Photon</a> Cloud region consists of at least one, but potentially multiple separate clusters. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This value is only getting updated when the client is on the master server. </dd></dl>

</div>
</div>
<a id="a6be49560fabd180debfd7d6c684b7abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be49560fabd180debfd7d6c684b7abe">&#9670;&nbsp;</a></span>getCurrentlyJoinedRoom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a11758.html">MutableRoom</a> &amp; getCurrentlyJoinedRoom </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const reference to a <a class="el" href="a11758.html">MutableRoom</a> instance that represents the currently joined room. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The behavior when accessing the referenced instance after leaving the room in which that reference has been obtained and the behavior when calling this function without being inside a room is undefined. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Attention: Do not assign the return value of this function to a <a class="el" href="a11758.html">MutableRoom</a> variable, but only assign it to a <a class="el" href="a11758.html">MutableRoom</a> reference or simply directly operate on the function return value, as assigning it to a variable means that accessing that variable lets you operate on a local copy and operations that change that copy don't affect the actual room. </dd></dl>

</div>
</div>
<a id="a362213f78e13ec5c38a46f836976a03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362213f78e13ec5c38a46f836976a03b">&#9670;&nbsp;</a></span>getRoomList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a10810.html">JVector</a>&lt; <a class="el" href="a11774.html">Room</a> * &gt; &amp; getRoomList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the list of all visible game rooms. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The value that is returned by this function is only updated inside a lobby of <a class="el" href="a10658.html#a30c451d8c36cb067661cbe71e62eb2d6" title="This lobby type is used unless another lobby type is specified. Room lists will be sent and Client::o...">LobbyType::DEFAULT</a>. Clients that are inside a lobby of a different <a class="el" href="a10658.html">LobbyType</a>, or in no lobby at all, do not receive room list updates. The same <a class="el" href="a11686.html">Client</a> instance can't be inside of multiple rooms at once. The term 'room' includes game rooms and lobbies. Therefor a <a class="el" href="a11686.html">Client</a> instance is not able to receive room list updates while it resides inside of a game room. </dd>
<dd>
To show up in the lobby the IsVisible flag of a game room needs to be set to true (which is the default value). The MaxPlayers setting and the current amount of players inside a room do not influence the rooms visibility, nor does the IsOpen flag: If the maximum amount of players is already inside of the room or if the room is closed, then the room is still included in the room list, but attempts to join it will fail. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a0ed85654a413546fc23f9f2097ab5d18">getRoomNameList()</a> </dd></dl>

</div>
</div>
<a id="a0ed85654a413546fc23f9f2097ab5d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed85654a413546fc23f9f2097ab5d18">&#9670;&nbsp;</a></span>getRoomNameList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a10810.html">JVector</a>&lt; <a class="el" href="a11510.html">JString</a> &gt; &amp; getRoomNameList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the list of the names of all visible game rooms.</dd></dl>
<p>The entries in the returned JVector instance are guarenteed to be in the same order like the entries in the JVector instance that is returned by <a class="el" href="a11686.html#a362213f78e13ec5c38a46f836976a03b">getRoomList()</a>. The same remarks apply to this function as are mentioned for <a class="el" href="a11686.html#a362213f78e13ec5c38a46f836976a03b">getRoomList()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a362213f78e13ec5c38a46f836976a03b">getRoomList()</a> </dd></dl>

</div>
</div>
<a id="a3d99cc1ff206755096a0befc9e355a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d99cc1ff206755096a0befc9e355a3c">&#9670;&nbsp;</a></span>getIsInRoom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getIsInRoom </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this client instance currently resides within a room, false otherwise. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The term 'room' includes game rooms and lobbies.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#ab6bcee6b8cf407301596f2ea8efa88f1">getIsInGameRoom()</a>, <a class="el" href="a11686.html#ad1d4b6a2163b213635c7b9fb49527517">getIsInLobby()</a> </dd></dl>

</div>
</div>
<a id="ab6bcee6b8cf407301596f2ea8efa88f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bcee6b8cf407301596f2ea8efa88f1">&#9670;&nbsp;</a></span>getIsInGameRoom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getIsInGameRoom </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this client instance currently resides within a game room, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a3d99cc1ff206755096a0befc9e355a3c">getIsInRoom()</a>, <a class="el" href="a11686.html#ad1d4b6a2163b213635c7b9fb49527517">getIsInLobby()</a> </dd></dl>

</div>
</div>
<a id="ad1d4b6a2163b213635c7b9fb49527517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d4b6a2163b213635c7b9fb49527517">&#9670;&nbsp;</a></span>getIsInLobby()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getIsInLobby </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if this client instance currently resides within a lobby, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a3d99cc1ff206755096a0befc9e355a3c">getIsInRoom()</a>, <a class="el" href="a11686.html#ab6bcee6b8cf407301596f2ea8efa88f1">getIsInGameRoom()</a> </dd></dl>

</div>
</div>
<a id="afad8d152e3340453133667a501fd4086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad8d152e3340453133667a501fd4086">&#9670;&nbsp;</a></span>getAutoJoinLobby()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getAutoJoinLobby </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the current value of the autJoinLobby flag. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The value of the autoJoinLobby flag determines if the client will automatically join the default lobby whenever it has successfully connected and whenever it leaves a game room. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#aa45e5ba66ec8f4a4ef08c3b499c52593">setAutoJoinLobby()</a> </dd></dl>

</div>
</div>
<a id="aa45e5ba66ec8f4a4ef08c3b499c52593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45e5ba66ec8f4a4ef08c3b499c52593">&#9670;&nbsp;</a></span>setAutoJoinLobby()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setAutoJoinLobby </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoJoinLobby</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of the autJoinLobby flag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">autoJoinLobby</td><td>the new value to which the flag will be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The value of the autoJoinLobby flag determines if the client will automatically join the default lobby whenever it has successfully connected and whenever it leaves a game room.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#afad8d152e3340453133667a501fd4086">getAutoJoinLobby()</a> </dd></dl>

</div>
</div>
<a id="a2ba431d51ab9d3009ddf6b2776fccca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba431d51ab9d3009ddf6b2776fccca3">&#9670;&nbsp;</a></span>getLocalPlayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a11754.html">MutablePlayer</a> &amp; getLocalPlayer </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const reference to the <a class="el" href="a11754.html">MutablePlayer</a> instance that is representing the local player. </dd></dl>

</div>
</div>
<a id="ab3d297b0e3b0a3545d2c63e029bcf562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d297b0e3b0a3545d2c63e029bcf562">&#9670;&nbsp;</a></span>getFriendList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a10810.html">JVector</a>&lt; <a class="el" href="a11694.html">FriendInfo</a> &gt; &amp; getFriendList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the latest locally cached state of the friend list. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>You can request the latest state of the local clients friend list from the server by a call to <a class="el" href="a11686.html#a62feeb633da4d11b9675dd0bfc41ecf8">opFindFriends()</a>. Listener::onFindFriendsResponse() informs you when the servers response has arrived. The list that is returned by this function reflects the state that the server has sent in its latest response to an update request or in other words the most up to date state that is available locally at the time of the call. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11686.html#a62feeb633da4d11b9675dd0bfc41ecf8">opFindFriends()</a>, Listener::onFindFriendsResponse(), <a class="el" href="a11694.html">FriendInfo</a>, <a class="el" href="a11686.html#af61b642c390d6448ad2fd30ce90f0c07">getFriendListAge()</a> </dd></dl>

</div>
</div>
<a id="af61b642c390d6448ad2fd30ce90f0c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61b642c390d6448ad2fd30ce90f0c07">&#9670;&nbsp;</a></span>getFriendListAge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getFriendListAge </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the time in ms that has passed since the last update has been applied to the list that is returned by <a class="el" href="a11686.html#ab3d297b0e3b0a3545d2c63e029bcf562">getFriendList()</a> or 0 if either no friendlist is available yet or if a request for an update is in progress at the time of the call. </dd></dl>

</div>
</div>
<a id="a03f1adb2a9394f24aa7ce42b281e99b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f1adb2a9394f24aa7ce42b281e99b9">&#9670;&nbsp;</a></span>getDisconnectedCause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getDisconnectedCause </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Summarizes (aggregates) the different causes for disconnects of a client. A disconnect can be caused by: errors in the network connection or some vital operation failing (which is considered "high level"). While operations always trigger a call to OnOperationResponse, connection related changes are treated in OnStatusChanged. The <a class="el" href="a10656.html">DisconnectCause</a> is set in either case and summarizes the causes for any disconnect in a single state value which can be used to display (or debug) the cause for disconnection. </p><dl class="section return"><dt>Returns</dt><dd>the disconnect cause. </dd></dl>

</div>
</div>
<a id="a3452520ad1bd930bf6e7f62be14fb609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3452520ad1bd930bf6e7f62be14fb609">&#9670;&nbsp;</a></span>getUserID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a11510.html">JString</a> &amp; getUserID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the unique user ID </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setUserID() </dd></dl>

</div>
</div>
<a id="a91ccef9856816076a0affd88619319e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ccef9856816076a0affd88619319e0">&#9670;&nbsp;</a></span>getRegionWithBestPing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a11510.html">JString</a> &amp; getRegionWithBestPing </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the region code of the <a class="el" href="a10635.html">Photon</a> Cloud region to which the client has the best ping. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>When you specify RegionSelectionMode::BEST on constructing the <a class="el" href="a11686.html">Client</a> instance, then on first connect the <a class="el" href="a11686.html">Client</a> will aquire a list of available regions and of their adresses and ping each of them multiple times. Afterwards it will connect to the region with the lowest average ping. After you got a call to Listener::connectReturn(), the region code of the region that the <a class="el" href="a11686.html">Client</a> has chosen based on the ping results can get accessed by a call to this function. Later calls to <a class="el" href="a11686.html#a952bb842759dee3916ceade681783456">connect()</a> will use that cached region code to avoid re-doing the time-consuming ping-procedure and therefor to keep the time short that is needed for establishing a connection. For the same reason it is recommend that you acquire the result of the ping-procedure through this function and store it in local persistant storage, so that you can use it with RegionSelectionMode::SELECT. This way you can avoid the time-consuming pinging procedure even for the first connect after constructing the class, if you already have the region code for the region with the best ping stored locally from a connection on another <a class="el" href="a11686.html">Client</a> instance (for example after your app has been shut down and restarted). However in this case you may want to provide an option to your users through which they can delete your locally stored region code and this way trigger a re-pinging on the next construction of a <a class="el" href="a11686.html">Client</a> instance. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function will return an empty string, if no ping result is available (yet), which is the case when another RegionSelectionMode than BEST has been chosen or when you have not received the call to Listener::connectReturn() yet that corresponds to your first successfully established connection since the construction of this class. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<footer style="border-top: 1px solid #444; margin-top: 1em; padding: 1em;">
    <div style="float: left;">
        &copy;&nbsp;<a href="https://www.photonengine.com/"> Exit Games &reg;</a>, all rights reserved.
    </div>
    <div style="float: right;">
        <a href="http://doc.photonengine.com/">Photon Documentation</a> |
        <a href="http://www.photonengine.com/en/contact">Contact</a> |
        <a href="https://www.photonengine.com/en/account/terms">Terms</a>
    <div>
    <b style="clear: both;"></b>
</footer>
<script>
  (function() {
    var cx = '015653142792304683059:ykdoyzkcyu4';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
</body>
</html>