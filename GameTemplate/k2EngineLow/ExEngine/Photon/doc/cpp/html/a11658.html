<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="UTF-8" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="generator" content="Doxygen 1.8.17"/>
    <meta name="addsearch-custom-field" content="product=realtime"/>
    <meta name="addsearch-custom-field" content="version=current"/>
    <meta name="addsearch-category" content="realtime/current" />
    <title>Photon C++ Client API: PhotonPeer Class Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link rel="alternate" type="text/xml" title="RSS" href="http://feeds.feedburner.com/exitgamesphoton">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="http://feeds.feedburner.com/exitgamesphoton">
    <!-- For IE: -->
    <link rel="shortcut icon" href="/favicon.ico" type="image/vnd.microsoft.icon">
    <!-- For Browsers, Android: -->
    <link rel="icon" sizes="192x192" href="/touch-icon-192x192.png">
    <link rel="icon" sizes="57x57" href="/apple-touch-icon-precomposed.png">
    <!-- For iPhone 6 Plus: -->
    <link rel="apple-touch-icon-precomposed" sizes="180x180" href="/apple-touch-icon-180x180-precomposed.png">
    <!-- For iPad running iOS = 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/apple-touch-icon-152x152-precomposed.png">
    <!-- For iPhone running iOS = 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/apple-touch-icon-120x120-precomposed.png">
    <!-- For the iPad mini and the first- and second-generation iPad on iOS = 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/apple-touch-icon-76x76-precomposed.png">
    <!-- For non-Retina iPhone, iPod Touch, and Android 2.1+ devices: -->
    <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png">
    <style>
        @charset "UTF-8";
        @import url(//fonts.googleapis.com/css?family=Open+Sans:300,600,700);
        html,
        body {
            height: 100.1%;
        }
        body {
            font-family: "Open Sans", Verdana, Helvetica, Arial, sans-serif;
            line-height: 1.51803398875;
                -webkit-font-smoothing: antialiased;
                -webkit-text-size-adjust: 100%;
            text-rendering: optimizeLegibility;
        }
        #projectname { font-size: 200%; }
        #projectname img {
            vertical-align: sub;
            margin-right: .2em;
        }
    </style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <table cellspacing="0" cellpadding="0" style="width: 100%;">
        <tbody>
            <tr style="height: 56px;">
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">
                        <img alt="" src="logo.png">
                        Photon C++ Client API
                    &#160;<span id="projectnumber">5.0.0.0</span>
                    </div>
                </td>
                <td style="width: 50%;"><gcse:search linktarget="_parent"></gcse:search></td>
            </tr>
        </tbody>
    </table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a10622.html">ExitGames</a></li><li class="navelem"><a class="el" href="a10635.html">Photon</a></li><li class="navelem"><a class="el" href="a11658.html">PhotonPeer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="a11655.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PhotonPeer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for PhotonPeer:</div>
<div class="dyncontent">
<div class="center"><img src="a11657.gif" border="0" usemap="#_photon_peer_inherit__map" alt="Inheritance graph"/></div>
<map name="_photon_peer_inherit__map" id="_photon_peer_inherit__map">
<area shape="rect" title=" " alt="" coords="5,5,83,29"/>
<area shape="rect" href="a11818.html" title=" " alt="" coords="22,77,66,101"/>
<area shape="rect" href="a11642.html" title=" " alt="" coords="91,77,152,101"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b9a30e3bf19d1a61363746ccfb2329a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a4b9a30e3bf19d1a61363746ccfb2329a">PhotonPeer</a> (<a class="el" href="a11654.html">PhotonListener</a> &amp;listener, nByte connectionProtocol=ConnectionProtocol::DEFAULT)</td></tr>
<tr class="separator:a4b9a30e3bf19d1a61363746ccfb2329a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313f46953d3a15d0141f7d0bd5a8febe"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a313f46953d3a15d0141f7d0bd5a8febe">~PhotonPeer</a> (void)</td></tr>
<tr class="separator:a313f46953d3a15d0141f7d0bd5a8febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350712dc9e140a7368a950d46f16ea56"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a350712dc9e140a7368a950d46f16ea56">connect</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;ipAddr, const <a class="el" href="a11510.html">Common::JString</a> &amp;appID=<a class="el" href="a11510.html">Common::JString</a>())</td></tr>
<tr class="separator:a350712dc9e140a7368a950d46f16ea56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f332f05fdc0bfb4f4075bdbf487375"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:a66f332f05fdc0bfb4f4075bdbf487375"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11658.html#a66f332f05fdc0bfb4f4075bdbf487375">connect</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;ipAddr, const <a class="el" href="a11510.html">Common::JString</a> &amp;appID, const Ftype &amp;customData)</td></tr>
<tr class="separator:a66f332f05fdc0bfb4f4075bdbf487375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed50454b83144433aa65fdfb18666aa5"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:aed50454b83144433aa65fdfb18666aa5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11658.html#aed50454b83144433aa65fdfb18666aa5">connect</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;ipAddr, const <a class="el" href="a11510.html">Common::JString</a> &amp;appID, const Ftype pCustomDataArray, typename Common::Helpers::ArrayLengthType&lt; Ftype &gt;::type arrSize)</td></tr>
<tr class="separator:aed50454b83144433aa65fdfb18666aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad489869a2c36cabdb9847bda31947fa7"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:ad489869a2c36cabdb9847bda31947fa7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a11658.html#ad489869a2c36cabdb9847bda31947fa7">connect</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;ipAddr, const <a class="el" href="a11510.html">Common::JString</a> &amp;appID, const Ftype pCustomDataArray, const short *pArrSizes)</td></tr>
<tr class="separator:ad489869a2c36cabdb9847bda31947fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888a5acf1fe3a8902f7cb2f5039cb334"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a888a5acf1fe3a8902f7cb2f5039cb334">disconnect</a> (void)</td></tr>
<tr class="separator:a888a5acf1fe3a8902f7cb2f5039cb334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66e8bb0fdc525c5e250092c35343a2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service</a> (bool <a class="el" href="a11658.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands</a>=true)</td></tr>
<tr class="separator:ac66e8bb0fdc525c5e250092c35343a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29567202b6f36cf6805209c2299d912"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#ab29567202b6f36cf6805209c2299d912">serviceBasic</a> (void)</td></tr>
<tr class="separator:ab29567202b6f36cf6805209c2299d912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1268775eba0cfe2b6f7e309a27e2fd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a3c1268775eba0cfe2b6f7e309a27e2fd">opCustom</a> (const <a class="el" href="a11646.html">OperationRequest</a> &amp;operationRequest, bool sendReliable, nByte channelID=0, bool encrypt=false)</td></tr>
<tr class="separator:a3c1268775eba0cfe2b6f7e309a27e2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8607574c36273d920ff3c859d65b5b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands</a> (void)</td></tr>
<tr class="separator:a5f8607574c36273d920ff3c859d65b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab7bcb13d946d8938fb13dc3f7b61e8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a3ab7bcb13d946d8938fb13dc3f7b61e8">sendAcksOnly</a> (void)</td></tr>
<tr class="separator:a3ab7bcb13d946d8938fb13dc3f7b61e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be00ecc71ec66c70629a9064d397d2b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands</a> (void)</td></tr>
<tr class="separator:a4be00ecc71ec66c70629a9064d397d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ac22c1480ba011cf646db5a1038f63"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a65ac22c1480ba011cf646db5a1038f63">establishEncryption</a> (void)</td></tr>
<tr class="separator:a65ac22c1480ba011cf646db5a1038f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e6e2243583f7cf42b8123e068302e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#ab2e6e2243583f7cf42b8123e068302e9">fetchServerTimestamp</a> (void)</td></tr>
<tr class="separator:ab2e6e2243583f7cf42b8123e068302e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4520fdb8e90d2474bd746b8e106b7ab3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a4520fdb8e90d2474bd746b8e106b7ab3">resetTrafficStats</a> (void)</td></tr>
<tr class="separator:a4520fdb8e90d2474bd746b8e106b7ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bb99da60472492742cb3b20b1b8d7a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#ae5bb99da60472492742cb3b20b1b8d7a">resetTrafficStatsMaximumCounters</a> (void)</td></tr>
<tr class="separator:ae5bb99da60472492742cb3b20b1b8d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6602b0d4251a5c65149f21d1eec6a127"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a11510.html">Common::JString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a6602b0d4251a5c65149f21d1eec6a127">vitalStatsToString</a> (bool all) const</td></tr>
<tr class="separator:a6602b0d4251a5c65149f21d1eec6a127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3a65954d71c350fff2a53619b2322e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#acd3a65954d71c350fff2a53619b2322e">pingServer</a> (const <a class="el" href="a11510.html">Common::JString</a> &amp;address, unsigned int pingAttempts)</td></tr>
<tr class="separator:acd3a65954d71c350fff2a53619b2322e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa316328ce29a9de94bcc82b42ac1c220"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#aa316328ce29a9de94bcc82b42ac1c220">initUserDataEncryption</a> (const <a class="el" href="a10810.html">Common::JVector</a>&lt; nByte &gt; &amp;secret)</td></tr>
<tr class="separator:aa316328ce29a9de94bcc82b42ac1c220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b99f5c56ea31f81e01cb1c95829ddf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a78b99f5c56ea31f81e01cb1c95829ddf">initUDPEncryption</a> (const <a class="el" href="a10810.html">Common::JVector</a>&lt; nByte &gt; &amp;encryptSecret, const <a class="el" href="a10810.html">Common::JVector</a>&lt; nByte &gt; &amp;HMACSecret=<a class="el" href="a10810.html">Common::JVector</a>&lt; nByte &gt;())</td></tr>
<tr class="separator:a78b99f5c56ea31f81e01cb1c95829ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05fbe47a4af8057aee1e55b9869fcba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a11654.html">PhotonListener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#af05fbe47a4af8057aee1e55b9869fcba">getListener</a> (void)</td></tr>
<tr class="separator:af05fbe47a4af8057aee1e55b9869fcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900f6a3f619a74f8bc341f59c69b4380"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a900f6a3f619a74f8bc341f59c69b4380">getServerTimeOffset</a> (void) const</td></tr>
<tr class="separator:a900f6a3f619a74f8bc341f59c69b4380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa108814e82124d5f4af471ea4ffb610a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#aa108814e82124d5f4af471ea4ffb610a">getServerTime</a> (void) const</td></tr>
<tr class="separator:aa108814e82124d5f4af471ea4ffb610a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bf9454763f5626f1192700072c174d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#ad4bf9454763f5626f1192700072c174d">getBytesOut</a> (void) const</td></tr>
<tr class="separator:ad4bf9454763f5626f1192700072c174d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8635d0982d8288ca623c8ff69c057c99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a8635d0982d8288ca623c8ff69c057c99">getBytesIn</a> (void) const</td></tr>
<tr class="separator:a8635d0982d8288ca623c8ff69c057c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263a49684b3758d495c41872d56d0957"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a263a49684b3758d495c41872d56d0957">getByteCountCurrentDispatch</a> (void) const</td></tr>
<tr class="separator:a263a49684b3758d495c41872d56d0957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee1554a47db34977491552bcd256d6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a6ee1554a47db34977491552bcd256d6c">getByteCountLastOperation</a> (void) const</td></tr>
<tr class="separator:a6ee1554a47db34977491552bcd256d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c9c97c5d8c6ccddd7f916f7cf2576b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a09c9c97c5d8c6ccddd7f916f7cf2576b">getPeerState</a> (void) const</td></tr>
<tr class="separator:a09c9c97c5d8c6ccddd7f916f7cf2576b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e39d83514f8803df537245cf23db14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#ac8e39d83514f8803df537245cf23db14">getSentCountAllowance</a> (void) const</td></tr>
<tr class="separator:ac8e39d83514f8803df537245cf23db14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6f199c62967e857482a2e6ae0cd95d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a9a6f199c62967e857482a2e6ae0cd95d">setSentCountAllowance</a> (int sentCountAllowance)</td></tr>
<tr class="separator:a9a6f199c62967e857482a2e6ae0cd95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40fc8e3f6004b9cbd6f99290e6aa4d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#af40fc8e3f6004b9cbd6f99290e6aa4d8">getTimePingInterval</a> (void) const</td></tr>
<tr class="separator:af40fc8e3f6004b9cbd6f99290e6aa4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f6b25436dc87fe34f53c2eec8df65a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#aa7f6b25436dc87fe34f53c2eec8df65a">setTimePingInterval</a> (int timePingInterval)</td></tr>
<tr class="separator:aa7f6b25436dc87fe34f53c2eec8df65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85101f9ea38bc642cb74ec4ae571b9fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a85101f9ea38bc642cb74ec4ae571b9fb">getRoundTripTime</a> (void) const</td></tr>
<tr class="separator:a85101f9ea38bc642cb74ec4ae571b9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace25d38b4d458e3dfb0b670ecd317682"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#ace25d38b4d458e3dfb0b670ecd317682">getRoundTripTimeVariance</a> (void) const</td></tr>
<tr class="separator:ace25d38b4d458e3dfb0b670ecd317682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea076259cd369fb751e50467adea2361"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#aea076259cd369fb751e50467adea2361">getTimestampOfLastSocketReceive</a> (void) const</td></tr>
<tr class="separator:aea076259cd369fb751e50467adea2361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee10207cc62f0fa06f3b8853621295a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#acee10207cc62f0fa06f3b8853621295a">getDebugOutputLevel</a> (void) const</td></tr>
<tr class="separator:acee10207cc62f0fa06f3b8853621295a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163e299695ce92d2f02eb4b78b29ab2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a163e299695ce92d2f02eb4b78b29ab2b">setDebugOutputLevel</a> (int debugLevel)</td></tr>
<tr class="separator:a163e299695ce92d2f02eb4b78b29ab2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61033342848847f071fa6d35aff19f37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a11522.html">Common::LogFormatOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a61033342848847f071fa6d35aff19f37">getLogFormatOptions</a> (void) const</td></tr>
<tr class="separator:a61033342848847f071fa6d35aff19f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f7c93e1c773e9369da96bb1e7dd2e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#ae5f7c93e1c773e9369da96bb1e7dd2e3">setLogFormatOptions</a> (const <a class="el" href="a11522.html">Common::LogFormatOptions</a> &amp;formatOptions)</td></tr>
<tr class="separator:ae5f7c93e1c773e9369da96bb1e7dd2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7493c7adc48661bc30026674de31d561"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a7493c7adc48661bc30026674de31d561">getIncomingReliableCommandsCount</a> (void) const</td></tr>
<tr class="separator:a7493c7adc48661bc30026674de31d561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ffbf998c2d43f7261e31a3858e3e18"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a57ffbf998c2d43f7261e31a3858e3e18">getPeerID</a> (void) const</td></tr>
<tr class="separator:a57ffbf998c2d43f7261e31a3858e3e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdda1b98b605e108ac6950d9c2d8ff3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#acdda1b98b605e108ac6950d9c2d8ff3b">getDisconnectTimeout</a> (void) const</td></tr>
<tr class="separator:acdda1b98b605e108ac6950d9c2d8ff3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9e8b780e386121f1b33b3f1c95c123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a9f9e8b780e386121f1b33b3f1c95c123">setDisconnectTimeout</a> (int disconnectTimeout)</td></tr>
<tr class="separator:a9f9e8b780e386121f1b33b3f1c95c123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ca352fb9c22793bf6a1f534fd9eedb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a82ca352fb9c22793bf6a1f534fd9eedb">getQueuedIncomingCommands</a> (void) const</td></tr>
<tr class="separator:a82ca352fb9c22793bf6a1f534fd9eedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3173bc58e2727d71e30e6a44279aabcd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a3173bc58e2727d71e30e6a44279aabcd">getQueuedOutgoingCommands</a> (void) const</td></tr>
<tr class="separator:a3173bc58e2727d71e30e6a44279aabcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66443de75b3ba8dee71726ef035b9146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a11510.html">Common::JString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a66443de75b3ba8dee71726ef035b9146">getServerAddress</a> (void) const</td></tr>
<tr class="separator:a66443de75b3ba8dee71726ef035b9146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128dedaab588e53ded9fd9b7708e140b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a128dedaab588e53ded9fd9b7708e140b">getIsPayloadEncryptionAvailable</a> (void) const</td></tr>
<tr class="separator:a128dedaab588e53ded9fd9b7708e140b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb9753eb4af1ebe91f31d0015ee20f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#abeb9753eb4af1ebe91f31d0015ee20f4">getIsEncryptionAvailable</a> (void) const</td></tr>
<tr class="separator:abeb9753eb4af1ebe91f31d0015ee20f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf52333d72638f95904828d4abebdc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#aedf52333d72638f95904828d4abebdc4">getResentReliableCommands</a> (void) const</td></tr>
<tr class="separator:aedf52333d72638f95904828d4abebdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0ae75e5cbd27385fac17357795d239"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a8e0ae75e5cbd27385fac17357795d239">getLimitOfUnreliableCommands</a> (void) const</td></tr>
<tr class="separator:a8e0ae75e5cbd27385fac17357795d239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675a14def7ed1f13d8851c2c509fda44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a675a14def7ed1f13d8851c2c509fda44">setLimitOfUnreliableCommands</a> (int value)</td></tr>
<tr class="separator:a675a14def7ed1f13d8851c2c509fda44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd6583f9b6732f5217b69de3016ef8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#aacd6583f9b6732f5217b69de3016ef8d">getCRCEnabled</a> (void) const</td></tr>
<tr class="separator:aacd6583f9b6732f5217b69de3016ef8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86720f73f3549fe7cec3c48aaaed2dea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a86720f73f3549fe7cec3c48aaaed2dea">setCRCEnabled</a> (bool crcEnabled)</td></tr>
<tr class="separator:a86720f73f3549fe7cec3c48aaaed2dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21ce2fab19a7f89371b55b80e9a6104"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#ac21ce2fab19a7f89371b55b80e9a6104">getPacketLossByCRC</a> (void) const</td></tr>
<tr class="separator:ac21ce2fab19a7f89371b55b80e9a6104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63818ef2534cb686799ba4b8089d87b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a63818ef2534cb686799ba4b8089d87b1">getTrafficStatsEnabled</a> (void) const</td></tr>
<tr class="separator:a63818ef2534cb686799ba4b8089d87b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205ce7c707be94fea1fa0991b5591e7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a205ce7c707be94fea1fa0991b5591e7c">setTrafficStatsEnabled</a> (bool trafficStasEnabled)</td></tr>
<tr class="separator:a205ce7c707be94fea1fa0991b5591e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fd6df74699a45931166b13b8473969"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#aa9fd6df74699a45931166b13b8473969">getTrafficStatsElapsedMs</a> (void) const</td></tr>
<tr class="separator:aa9fd6df74699a45931166b13b8473969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9db711d733ea73b6bcbb49c9dca431"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a11674.html">TrafficStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a5f9db711d733ea73b6bcbb49c9dca431">getTrafficStatsIncoming</a> (void) const</td></tr>
<tr class="separator:a5f9db711d733ea73b6bcbb49c9dca431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef71b634eb9c5206e7ee625b65a34f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a11674.html">TrafficStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#afef71b634eb9c5206e7ee625b65a34f6">getTrafficStatsOutgoing</a> (void) const</td></tr>
<tr class="separator:afef71b634eb9c5206e7ee625b65a34f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98257fc026ad5d7863a5692d1de91769"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a11678.html">TrafficStatsGameLevel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a98257fc026ad5d7863a5692d1de91769">getTrafficStatsGameLevel</a> (void) const</td></tr>
<tr class="separator:a98257fc026ad5d7863a5692d1de91769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2b890f4b3dd79360358b3afaffd9e8"><td class="memItemLeft" align="right" valign="top">nByte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#adb2b890f4b3dd79360358b3afaffd9e8">getQuickResendAttempts</a> (void) const</td></tr>
<tr class="separator:adb2b890f4b3dd79360358b3afaffd9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a43056816067b306fc0feb54bcd97f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a2a43056816067b306fc0feb54bcd97f5">setQuickResendAttempts</a> (nByte quickResendAttempts)</td></tr>
<tr class="separator:a2a43056816067b306fc0feb54bcd97f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08cedfa555dddb5394a000a5ede9079"><td class="memItemLeft" align="right" valign="top">nByte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#ab08cedfa555dddb5394a000a5ede9079">getConnectionProtocol</a> (void) const</td></tr>
<tr class="separator:ab08cedfa555dddb5394a000a5ede9079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3ba3c7b9229c180cbcbe5de35ed77a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a5f3ba3c7b9229c180cbcbe5de35ed77a">setConnectionProtocol</a> (nByte connectionProtocol)</td></tr>
<tr class="separator:a5f3ba3c7b9229c180cbcbe5de35ed77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8dacd122e7d5ebaeee1f309a2858b8"><td class="memItemLeft" align="right" valign="top">nByte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a1b8dacd122e7d5ebaeee1f309a2858b8">getChannelCountUserChannels</a> (void) const</td></tr>
<tr class="separator:a1b8dacd122e7d5ebaeee1f309a2858b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a10359924120048ca6281db6ed9dda97d"><td class="memItemLeft" align="right" valign="top">static short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a10359924120048ca6281db6ed9dda97d">getPeerCount</a> (void)</td></tr>
<tr class="separator:a10359924120048ca6281db6ed9dda97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188320d3f17c777953e635ee225d735b"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11658.html#a188320d3f17c777953e635ee225d735b">getMaxAppIDLength</a> (void)</td></tr>
<tr class="separator:a188320d3f17c777953e635ee225d735b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="a11658.html">PhotonPeer</a> class provides an API for reliable and unreliable realtime communication.</p>
<p><a class="el" href="a11658.html">PhotonPeer</a> uses the callback interface <a class="el" href="a11654.html">PhotonListener</a> that needs to be implemented by your application, to receive results and events from the Photon Server. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4b9a30e3bf19d1a61363746ccfb2329a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9a30e3bf19d1a61363746ccfb2329a">&#9670;&nbsp;</a></span>PhotonPeer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a11658.html">PhotonPeer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a11654.html">PhotonListener</a> &amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>connectionProtocol</em> = <code>ConnectionProtocol::DEFAULT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>Reference to the application's implementation of the Listener callback interface. Has to be valid for at least the lifetime of the <a class="el" href="a11658.html">PhotonPeer</a> instance, which is created by this constructor. </td></tr>
    <tr><td class="paramname">connectionProtocol</td><td>The protocol to use to connect to Photon. Must match one of the constants specified in <a class="el" href="a10636.html">ConnectionProtocol</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11654.html">PhotonListener</a>, <a class="el" href="a10636.html">ConnectionProtocol</a> </dd></dl>

</div>
</div>
<a id="a313f46953d3a15d0141f7d0bd5a8febe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313f46953d3a15d0141f7d0bd5a8febe">&#9670;&nbsp;</a></span>~PhotonPeer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="a11658.html">PhotonPeer</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a350712dc9e140a7368a950d46f16ea56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350712dc9e140a7368a950d46f16ea56">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>ipAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>appID</em> = <code><a class="el" href="a11510.html">Common::JString</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function starts establishing a connection to a Photon server. The servers response will arrive in <a class="el" href="a11654.html#a762c08d3437006f3da1165e296bb52b3">PhotonListener::onStatusChanged()</a>.</p>
<p>The connection is successfully established when the Photon client received a valid response from the server. The connect-attempt fails when a network error occurs or when server is not responding. A call to this function starts an asynchronous operation. The result of this operation gets returned through the <a class="el" href="a11654.html#a762c08d3437006f3da1165e296bb52b3">PhotonListener::onStatusChanged()</a> callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipAddr</td><td>A null terminated string containing the IP address or domain name and optionally the port number to connect to. IP addresses can be in IPv4 or IPv6 format, examples: "192.168.0.1", "192.168.0.1:5055", "udp.gameserver.com", "udp.gameserver.com:5055", "[2002:C0A8:1::]", "[2002:C0A8:1::]:5055". Note that IPv6 addresses must include square brackets to indicate where the address itself end and the port begins. If no port is given, then the default port for the chosen protocol and server type will be used. </td></tr>
    <tr><td class="paramname">appID</td><td>the appID (default: an empty string) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if it could successfully start establishing a connection (the result will be passed in the callback function in this case) or false, if an error occurred and the connection could not be established (the callback function will not be called then). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a888a5acf1fe3a8902f7cb2f5039cb334">disconnect()</a>, <a class="el" href="a10642.html">NetworkPort</a> </dd></dl>

</div>
</div>
<a id="a66f332f05fdc0bfb4f4075bdbf487375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f332f05fdc0bfb4f4075bdbf487375">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>ipAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>appID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ftype &amp;&#160;</td>
          <td class="paramname"><em>customData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipAddr</td><td>A Null terminated string containing the IP address or domain name and optionally a port of the server to connect to. Should be in the usual format: "address[:port]", for example: "192.168.0.1:5055" or "udp.gameserver.com". If no port is given, port 5055 will be used by default. </td></tr>
    <tr><td class="paramname">appID</td><td>the appID (default: an empty string) </td></tr>
    <tr><td class="paramname">customData</td><td>custom data to send to the server when initializing the connection - has to be provided in the form of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed50454b83144433aa65fdfb18666aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed50454b83144433aa65fdfb18666aa5">&#9670;&nbsp;</a></span>connect() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>ipAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>appID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ftype&#160;</td>
          <td class="paramname"><em>pCustomDataArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Common::Helpers::ArrayLengthType&lt; Ftype &gt;::type&#160;</td>
          <td class="paramname"><em>arrSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This overload accepts singledimensional arrays and NULL-pointers passed for parameter pCustomDataArray. NULL pointers are only legal input, if arrSize is 0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipAddr</td><td>Null terminated string containing IP address or domain name and optionally a port of server to connect. Should be in usual format: "address[:port]", for example: "192.168.0.1:5055" or "udp.gameserver.com". If no port is given, port 5055 will be used by default. </td></tr>
    <tr><td class="paramname">appID</td><td>the appID (default: an empty string) </td></tr>
    <tr><td class="paramname">pCustomDataArray</td><td>custom data to send to the server when initializing the connection - has to be provided in the form of a 1D array of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> </td></tr>
    <tr><td class="paramname">arrSize</td><td>the element count of the customData array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad489869a2c36cabdb9847bda31947fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad489869a2c36cabdb9847bda31947fa7">&#9670;&nbsp;</a></span>connect() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>ipAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>appID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ftype&#160;</td>
          <td class="paramname"><em>pCustomDataArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *&#160;</td>
          <td class="paramname"><em>pArrSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This overload accepts multidimensional arrays and NULL-pointers passed for parameter pCustomDataArray. The array that is passed for parameter pCustomDataArray has to be a pointer of the correct abstraction level, meaning a normal pointer for a singledimensional array, a doublepointer for a twodimensional array, a triplepointer for a threedimensional array and so on. For pCustomDataArray NULL pointers are only legal input, if pArrSizes[0] is 0. For pArrSizes NULL is no valid input. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipAddr</td><td>Null terminated string containing IP address or domain name and optionally a port of server to connect. Should be in usual format: "address[:port]", for example: "192.168.0.1:5055" or "udp.gameserver.com". If no port is given, port 5055 will be used by default. </td></tr>
    <tr><td class="paramname">appID</td><td>the appID (default: an empty string) </td></tr>
    <tr><td class="paramname">pCustomDataArray</td><td>custom data to send to the server when initializing the connection - has to be provided in the form of an array of one of the supported data types, specified at <a class="el" href="a12694.html">Table of Datatypes</a> </td></tr>
    <tr><td class="paramname">pArrSizes</td><td>the element counts for every dimension of the custom data array - the element count of this array has to match the dimensions of the custom data array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a888a5acf1fe3a8902f7cb2f5039cb334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888a5acf1fe3a8902f7cb2f5039cb334">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void disconnect </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiates the disconnection from the Photon server. The servers response will arrive in <a class="el" href="a11654.html#a762c08d3437006f3da1165e296bb52b3">PhotonListener::onStatusChanged()</a>.</p>
<p>This function generates a disconnection request that will be sent to the Photon server. If the disconnection is completed successfully, then the <a class="el" href="a11654.html#a762c08d3437006f3da1165e296bb52b3">PhotonListener::onStatusChanged()</a> callback will be called, with a statusCode of <a class="el" href="a10647.html#a83bc5f69121a66829551b1f355669b7e" title="the PhotonPeer just disconnected.">StatusCode::DISCONNECT</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a350712dc9e140a7368a950d46f16ea56">connect()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="a11762.html#a888a5acf1fe3a8902f7cb2f5039cb334">Peer</a>.</p>

</div>
</div>
<a id="ac66e8bb0fdc525c5e250092c35343a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66e8bb0fdc525c5e250092c35343a2d">&#9670;&nbsp;</a></span>service()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void service </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dispatchIncomingCommands</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function executes the <a class="el" href="a11658.html">PhotonPeer</a> internal processes. Call this regularly!</p>
<p>This function is meant to be called frequently, like once per game loop. It handles the internal calls for keeping the <a class="el" href="a11658.html">PhotonPeer</a> communication alive, and will take care of sending all local outgoing acknowledgements and messages, as well as dispatching incoming messages to the application and firing the corresponding callbacks. Internally <a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> calls the following functions:</p><ol type="1">
<li><a class="el" href="a11658.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a></li>
<li><a class="el" href="a11658.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> (called withing a loop until all incoming commands have been dispatched.)</li>
<li><a class="el" href="a11658.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> (called withing a loop until everything queued for sending has been sent.)</li>
</ol>
<p><a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> is provided for convenience. If you need to tweak the performance, you can ignore <a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> and call its three subfunctions directly with individual time intervals, to gain more control over the internal communication process. For instance, calling <a class="el" href="a11658.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> more rarely will result in less packets to be generated, as more commands will be accumulated into a single packet. See <a class="el" href="a11658.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> for more information on efficiency.</p>
<p>For situations where you want to keep the connection alive, but can't process incoming messages (e.g. when loading a level), you can temporarily pass false for dispatchIncomingCommands to skip the calls to <a class="el" href="a11658.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a>. Incoming commands will be stored in the incoming queue until they are dispatched again. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatchIncomingCommands</td><td>true = <a class="el" href="a11658.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> will be called; false = <a class="el" href="a11658.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> won't be called, default is true </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab29567202b6f36cf6805209c2299d912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29567202b6f36cf6805209c2299d912">&#9670;&nbsp;</a></span>serviceBasic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serviceBasic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes care of exchanging data with the system's network layer.</p>
<p>You only need to call this function in case you choose not to use <a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a>, but call the subfunctions of <a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> directly. Please see the documentation of <a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> for more information.</p>
<p><a class="el" href="a11658.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> is called from within <a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a>. If you decide not to use <a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a>, then <a class="el" href="a11658.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> needs to be called frequently, like once per game loop. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> </dd></dl>

</div>
</div>
<a id="a3c1268775eba0cfe2b6f7e309a27e2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1268775eba0cfe2b6f7e309a27e2fd">&#9670;&nbsp;</a></span>opCustom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opCustom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11646.html">OperationRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>operationRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sendReliable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>channelID</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>encrypt</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sends a custom operation to a custom Server, using reliable or unreliable Photon transmission.</p>
<p>Allows the client to send a custom operation to the Photon server (which has to be modified accordingly). The Server can be extended and modified for special purposes like server side collision detection or a consistent world.</p>
<p>You need to be connected (see <a class="el" href="a11658.html#a350712dc9e140a7368a950d46f16ea56">connect()</a>) prior to calling <a class="el" href="a11658.html#a3c1268775eba0cfe2b6f7e309a27e2fd">opCustom()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operationRequest</td><td>holds the payload of the operation </td></tr>
    <tr><td class="paramname">sendReliable</td><td>= operation will be sent reliably; false = no resend in case of packet loss - will be ignored, when not using udp as protocol </td></tr>
    <tr><td class="paramname">channelID</td><td>the logical channel, default is 0. See <a class="el" href="a12696.html">Fragmentation and Channels</a> for more information. </td></tr>
    <tr><td class="paramname">encrypt</td><td>true = encrypt message; false = no encryption </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if successful, false otherwise </dd></dl>

</div>
</div>
<a id="a5f8607574c36273d920ff3c859d65b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8607574c36273d920ff3c859d65b5b">&#9670;&nbsp;</a></span>sendOutgoingCommands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sendOutgoingCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function initiates the transmission of outgoing commands.</p>
<p>Any Photon function that generates messages will store these messages as a "command" in an outgoing queue for later transmission. Commands can either be explicitly created operations generated for example by <a class="el" href="a11658.html#a3c1268775eba0cfe2b6f7e309a27e2fd">opCustom()</a> or internally generated messages like acknowledgements for reliable messages from other players. <a class="el" href="a11658.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> will initiate the data transmission by passing the outgoing commands to the system's sockets for immediate transmission.</p>
<p>In case of UDP <a class="el" href="a11658.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> will also split the commands into multiple packets if needed and/of aggregate multiple commands together into one packet, if possible. Because of the latter calling sendOutgoingcommands() more rarely will result in less overhead, as there will be fewer packets for the clients to be sent and processed. The underlying platform can also limit the frequency in which outgoing packets can be sent and received. The downside of lower sending frequencies is a higher latency, until messages are exchanged and acknowledged, which may lead to a jerky gameplay.</p>
<p>To help you keeping track of the incoming and outgoing queues at development time and adjust your sending frequency, there will be a warning message sent to your debugReturn callback if a queue has exceeded the warning threshold. </p><dl class="section note"><dt>Note</dt><dd>While <a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> is calling <a class="el" href="a11658.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> implicitly, you will have to regularly call it yourself explictly , when you use <a class="el" href="a11658.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> and <a class="el" href="a11658.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> directly instead.</dd></dl>
<p>Usually you don't have to call <a class="el" href="a11658.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> this explicitly, as this is done within <a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> </dd></dl>

</div>
</div>
<a id="a3ab7bcb13d946d8938fb13dc3f7b61e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab7bcb13d946d8938fb13dc3f7b61e8">&#9670;&nbsp;</a></span>sendAcksOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sendAcksOnly </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sends only ACKs (UDP) or Ping (TCP) instead of queued outgoing commands. Useful to pause sending actual data. </p><dl class="section note"><dt>Note</dt><dd>While <a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> is calling <a class="el" href="a11658.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> implicitly, you will have to regularly call it yourself explictly , when you use <a class="el" href="a11658.html#a3ab7bcb13d946d8938fb13dc3f7b61e8">sendAcksOnly()</a> and <a class="el" href="a11658.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> instead. </dd></dl>

</div>
</div>
<a id="a4be00ecc71ec66c70629a9064d397d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be00ecc71ec66c70629a9064d397d2b">&#9670;&nbsp;</a></span>dispatchIncomingCommands()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dispatchIncomingCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks for incoming commands waiting in the queue, and dispatches a single command to the application.</p>
<p>Dispatching means, that if the command is an operation response or an event, the appropriate callback function will be called). <a class="el" href="a11658.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> will also take care of generating and queuing acknowledgments for incoming reliable commands. Please note that this function will only dispatch one command per all. If you want to dispatch every single command which is waiting in the queue, call dipatchIncomingCommands() within a while loop, until its return code is false. </p><dl class="section note"><dt>Note</dt><dd>While <a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> is calling <a class="el" href="a11658.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> implicitly, you will have to regularly call it yourself explictly, when you use <a class="el" href="a11658.html#a5f8607574c36273d920ff3c859d65b5b">sendOutgoingCommands()</a> and <a class="el" href="a11658.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> directly instead. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if it has successfully dispatched a command, false otherwise (for example, when there has not been any command left in the queue, waiting for dispatching). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> </dd></dl>

</div>
</div>
<a id="a65ac22c1480ba011cf646db5a1038f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ac22c1480ba011cf646db5a1038f63">&#9670;&nbsp;</a></span>establishEncryption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool establishEncryption </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function creates a public key for this client and exchanges it with the server.</p>
<p>If <a class="el" href="a11658.html#a65ac22c1480ba011cf646db5a1038f63">establishEncryption()</a> returns true, then Photon will inform you about the successfull establishment or a failure by calling <a class="el" href="a11654.html#a762c08d3437006f3da1165e296bb52b3">PhotonListener::onStatusChanged()</a> with the statusCode beeing either <a class="el" href="a10647.html#a5823f487a4d6322558b9a654289a6657" title="The encryption-setup for secure communication finished successfully.">StatusCode::ENCRYPTION_ESTABLISHED</a> or <a class="el" href="a10647.html#a0af4e71c88a73a08ae4135423c0a7f0b" title="The encryption-setup failed for some reason. Check debug logs.">StatusCode::ENCRYPTION_FAILED_TO_ESTABLISH</a> </p><dl class="section return"><dt>Returns</dt><dd>true if encryption has been successfully initiated, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#abeb9753eb4af1ebe91f31d0015ee20f4">getIsEncryptionAvailable()</a>, <a class="el" href="a11658.html#a128dedaab588e53ded9fd9b7708e140b">getIsPayloadEncryptionAvailable()</a>, <a class="el" href="a11658.html#a78b99f5c56ea31f81e01cb1c95829ddf">initUDPEncryption()</a>, <a class="el" href="a11658.html#aa316328ce29a9de94bcc82b42ac1c220">initUserDataEncryption()</a> </dd></dl>

</div>
</div>
<a id="ab2e6e2243583f7cf42b8123e068302e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e6e2243583f7cf42b8123e068302e9">&#9670;&nbsp;</a></span>fetchServerTimestamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fetchServerTimestamp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will fetch the server's timestamp and update the approximation for <a class="el" href="a11658.html#aa108814e82124d5f4af471ea4ffb610a">getServerTime()</a> and <a class="el" href="a11658.html#a900f6a3f619a74f8bc341f59c69b4380">getServerTimeOffset()</a>.</p>
<p>The server time approximation will NOT become more accurate by repeated calls. Accuracy currently depends on a single roundtrip which is done as fast as possible.</p>
<p>The command used for this is immediately acknowledged by the server. This makes sure the roundtriptime is low and the timestamp + roundtriptime / 2 is close to the original value. </p>

</div>
</div>
<a id="a4520fdb8e90d2474bd746b8e106b7ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4520fdb8e90d2474bd746b8e106b7ab3">&#9670;&nbsp;</a></span>resetTrafficStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resetTrafficStats </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates new instances of <a class="el" href="a11674.html">TrafficStats</a> and starts a new timer for those. </p>

</div>
</div>
<a id="ae5bb99da60472492742cb3b20b1b8d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bb99da60472492742cb3b20b1b8d7a">&#9670;&nbsp;</a></span>resetTrafficStatsMaximumCounters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resetTrafficStatsMaximumCounters </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets traffic stats values that can be maxed out. </p>

</div>
</div>
<a id="a6602b0d4251a5c65149f21d1eec6a127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6602b0d4251a5c65149f21d1eec6a127">&#9670;&nbsp;</a></span>vitalStatsToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a11510.html">JString</a> vitalStatsToString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string of the most interesting connection statistics. When you have issues on the client side, these might contain hints about the issue's cause. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">all</td><td>If true, Incoming and Outgoing low-level stats are included in the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stats as a string. </dd></dl>

</div>
</div>
<a id="acd3a65954d71c350fff2a53619b2322e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3a65954d71c350fff2a53619b2322e">&#9670;&nbsp;</a></span>pingServer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pingServer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11510.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pingAttempts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sends a ping signal to the specified address.</p>
<p>Each call to this function results in a number of calls to <a class="el" href="a11654.html#afe7e3a5a9d658975ba5bc5c9836f8e98">PhotonListener::onPingResponse()</a> that equals the value which has been passed for parameter pingAttempts.</p>
<p>This function can be used to ping multiple <a class="el" href="a10635.html">Photon</a> servers and determine the one with the lowest latency.</p>
<p>As the latency of the same server may vary it can make sense to send multiple ping attempts. In that case the next attempt gets sent when either the servers response for the previous attempt has been received or when that previous attempt has timed out.</p>
<p>Multiple calls to this function do not get queued, but run in parallel.</p>
<p>A valid <a class="el" href="a10635.html">Photon</a> server must run at the specified address. </p><dl class="section note"><dt>Note</dt><dd>This function is not available on platforms that do not support those parts of the stdlib that have been introduced with C++ 11. </dd>
<dd>
This function is not available on platforms that do not support multi-threading. </dd>
<dd>
If the connection protocol of the <a class="el" href="a11658.html">PhotonPeer</a> instance is WS or WSS, then this function uses UDP for pinging, otherwise it uses the connection protocol of the <a class="el" href="a11658.html">PhotonPeer</a> instance for pinging. If you include a port number in the 'address' string and the connection protocol of the <a class="el" href="a11658.html">PhotonPeer</a> instance is WS or WSS, then that port number needs to be the UDP port of the server and not its WS or WSS port. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>the address, which should be pinged </td></tr>
    <tr><td class="paramname">pingAttempts</td><td>the amount of ping signals to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11654.html#afe7e3a5a9d658975ba5bc5c9836f8e98">PhotonListener::onPingResponse()</a> </dd></dl>

</div>
</div>
<a id="aa316328ce29a9de94bcc82b42ac1c220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa316328ce29a9de94bcc82b42ac1c220">&#9670;&nbsp;</a></span>initUserDataEncryption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initUserDataEncryption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; nByte &gt; &amp;&#160;</td>
          <td class="paramname"><em>secret</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes userData encryption with the provided key. </p><dl class="section note"><dt>Note</dt><dd>You must also provide the same key to the server to which you want to connect. It needs to be an aes256 key and must not have been received through an unsecured connection. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you don't already have generated a key that you can access securely on both, the client and the server, you may want to consider to use <a class="el" href="a11658.html#a65ac22c1480ba011cf646db5a1038f63">establishEncryption()</a> instead, which also initializes userData encryption, but does generate suitable keys on client and server side itself. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secret</td><td>an aes256 key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#abeb9753eb4af1ebe91f31d0015ee20f4">getIsEncryptionAvailable()</a>, <a class="el" href="a11658.html#a128dedaab588e53ded9fd9b7708e140b">getIsPayloadEncryptionAvailable()</a>, <a class="el" href="a11658.html#a65ac22c1480ba011cf646db5a1038f63">establishEncryption()</a>, <a class="el" href="a11658.html#a78b99f5c56ea31f81e01cb1c95829ddf">initUDPEncryption()</a> </dd></dl>

</div>
</div>
<a id="a78b99f5c56ea31f81e01cb1c95829ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b99f5c56ea31f81e01cb1c95829ddf">&#9670;&nbsp;</a></span>initUDPEncryption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void initUDPEncryption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; nByte &gt; &amp;&#160;</td>
          <td class="paramname"><em>encryptSecret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a10810.html">Common::JVector</a>&lt; nByte &gt; &amp;&#160;</td>
          <td class="paramname"><em>HMACSecret</em> = <code><a class="el" href="a10810.html">Common::JVector</a>&lt;nByte&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes UDP packet Data encryption with the provided keys.</p>
<p>This function has no effect for non-UDP connections, but you may still call it while having an active connection that uses a different protocol. In that case they keys will be stored in case that you switch the protocol at the time of a later re-connect. For XB1 UDP connections UDP packet encryption is a mandatory requirement by Microsoft. On other platforms you may also consider to use <a class="el" href="a11658.html#a65ac22c1480ba011cf646db5a1038f63">establishEncryption()</a> or <a class="el" href="a11658.html#aa316328ce29a9de94bcc82b42ac1c220">initUserDataEncryption()</a>, which provide alternative encryption implementations that do also work with other connection protocols. </p><dl class="section note"><dt>Note</dt><dd>You must also provide the same keys to the server to which you want to connect. They need to be aes256 keys and must not have been received through an unsecured connection. </dd>
<dd>
This function is only available on Windows Desktop, Windows Store and XBox 1. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encryptSecret</td><td>an aes256 key used for packet encryption </td></tr>
    <tr><td class="paramname">HMACSecret</td><td>an aes256 key used for packet authentication </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#abeb9753eb4af1ebe91f31d0015ee20f4">getIsEncryptionAvailable()</a>, <a class="el" href="a11658.html#a65ac22c1480ba011cf646db5a1038f63">establishEncryption()</a>, <a class="el" href="a11658.html#aa316328ce29a9de94bcc82b42ac1c220">initUserDataEncryption()</a> </dd></dl>

</div>
</div>
<a id="af05fbe47a4af8057aee1e55b9869fcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05fbe47a4af8057aee1e55b9869fcba">&#9670;&nbsp;</a></span>getListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a11654.html">PhotonListener</a> * getListener </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the application's implementation of the Listener callback interface, as passed to the constructor of <a class="el" href="a11658.html">PhotonPeer</a>. </dd></dl>

</div>
</div>
<a id="a900f6a3f619a74f8bc341f59c69b4380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900f6a3f619a74f8bc341f59c69b4380">&#9670;&nbsp;</a></span>getServerTimeOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getServerTimeOffset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the difference between the local uptime and the Photon Server's system time in ms.</dd></dl>
<p>In real-time games it's often useful to relate game events to a global common timeline, that's valid for all players and independent from derivations throughout the clients' system times. The Photon Server's System Time can serve as this reference time. The serverTimeOffset represents the difference between the client's local system time and the Photon server's system time.</p>
<p>ServerTime = serverTimeOffset + GETTIMEMS()</p>
<p>The serverTimeOffset is fetched shortly after connect by <a class="el" href="a10635.html">Photon</a>. Use GETTIMEMS() to get your local time in ms. You can let Photon refetch the offset by calling <a class="el" href="a11658.html#ab2e6e2243583f7cf42b8123e068302e9">fetchServerTimestamp()</a>. The ServerTimeOffset will be 0 until shortly after initial connect. </p>

</div>
</div>
<a id="aa108814e82124d5f4af471ea4ffb610a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa108814e82124d5f4af471ea4ffb610a">&#9670;&nbsp;</a></span>getServerTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getServerTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the Photon Server's system time ins ms.</dd></dl>
<p>see <a class="el" href="a11658.html#a900f6a3f619a74f8bc341f59c69b4380">getServerTimeOffset()</a> </p>

</div>
</div>
<a id="ad4bf9454763f5626f1192700072c174d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bf9454763f5626f1192700072c174d">&#9670;&nbsp;</a></span>getBytesOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getBytesOut </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of outgoing bytes transmitted by this <a class="el" href="a11658.html">PhotonPeer</a> object. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a8635d0982d8288ca623c8ff69c057c99">getBytesIn()</a> </dd></dl>

</div>
</div>
<a id="a8635d0982d8288ca623c8ff69c057c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8635d0982d8288ca623c8ff69c057c99">&#9670;&nbsp;</a></span>getBytesIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getBytesIn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of incoming bytes received by this <a class="el" href="a11658.html">PhotonPeer</a> object. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#ad4bf9454763f5626f1192700072c174d">getBytesOut()</a> </dd></dl>

</div>
</div>
<a id="a263a49684b3758d495c41872d56d0957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263a49684b3758d495c41872d56d0957">&#9670;&nbsp;</a></span>getByteCountCurrentDispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getByteCountCurrentDispatch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the dispatched event or operation-result in bytes. This value is set before onEvent() or onOperationResponse() is called (within <a class="el" href="a11658.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a>). Get this value directly in onEvent() or onOperationResponse(). </dd></dl>

</div>
</div>
<a id="a6ee1554a47db34977491552bcd256d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee1554a47db34977491552bcd256d6c">&#9670;&nbsp;</a></span>getByteCountLastOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getByteCountLastOperation </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the last serialized operation call in bytes. The value includes all headers for this single operation but excludes those of UDP, Enet Package Headers and TCP. Get this value immediately after calling an operation. </dd></dl>

</div>
</div>
<a id="a09c9c97c5d8c6ccddd7f916f7cf2576b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c9c97c5d8c6ccddd7f916f7cf2576b">&#9670;&nbsp;</a></span>getPeerState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getPeerState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the current state of the <a class="el" href="a11658.html">PhotonPeer</a> object</dd></dl>
<p>The state of the <a class="el" href="a11658.html">PhotonPeer</a> object is changed internally upon connection and disconnection, and will be one of the values of the <a class="el" href="a10645.html">PeerState</a> enum. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a350712dc9e140a7368a950d46f16ea56">connect()</a>, <a class="el" href="a11658.html#a888a5acf1fe3a8902f7cb2f5039cb334">disconnect()</a> </dd></dl>

</div>
</div>
<a id="ac8e39d83514f8803df537245cf23db14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e39d83514f8803df537245cf23db14">&#9670;&nbsp;</a></span>getSentCountAllowance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getSentCountAllowance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of resend retries before a peer is considered lost/disconnected.</dd></dl>
<p>This is udp specific and will always return 0 for other protocols. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a9a6f199c62967e857482a2e6ae0cd95d">setSentCountAllowance()</a> <a class="el" href="a11658.html#acdda1b98b605e108ac6950d9c2d8ff3b">getDisconnectTimeout()</a> <a class="el" href="a11658.html#a9f9e8b780e386121f1b33b3f1c95c123">setDisconnectTimeout()</a> </dd></dl>

</div>
</div>
<a id="a9a6f199c62967e857482a2e6ae0cd95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6f199c62967e857482a2e6ae0cd95d">&#9670;&nbsp;</a></span>setSentCountAllowance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSentCountAllowance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sentCountAllowance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the number of re-send retries before a peer is considered lost/disconnected.</p>
<p>This is udp specific and will do nothing at all for other protocols. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sentCountAllowance</td><td>the new number of re/-send retries before a peer is considered lost/disconnected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#ac8e39d83514f8803df537245cf23db14">getSentCountAllowance()</a> <a class="el" href="a11658.html#acdda1b98b605e108ac6950d9c2d8ff3b">getDisconnectTimeout()</a> <a class="el" href="a11658.html#a9f9e8b780e386121f1b33b3f1c95c123">setDisconnectTimeout()</a> </dd></dl>

</div>
</div>
<a id="af40fc8e3f6004b9cbd6f99290e6aa4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40fc8e3f6004b9cbd6f99290e6aa4d8">&#9670;&nbsp;</a></span>getTimePingInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getTimePingInterval </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the time threshold in milliseconds since the last reliable command, before a ping will be sent. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#aa7f6b25436dc87fe34f53c2eec8df65a">setTimePingInterval()</a> </dd></dl>

</div>
</div>
<a id="aa7f6b25436dc87fe34f53c2eec8df65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f6b25436dc87fe34f53c2eec8df65a">&#9670;&nbsp;</a></span>setTimePingInterval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setTimePingInterval </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timePingInterval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the time threshold in milliseconds since the last reliable command, before a ping will be sent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timePingInterval</td><td>time threshold in milliseconds since the last reliable command, before a ping will be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#af40fc8e3f6004b9cbd6f99290e6aa4d8">getTimePingInterval()</a> </dd></dl>

</div>
</div>
<a id="a85101f9ea38bc642cb74ec4ae571b9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85101f9ea38bc642cb74ec4ae571b9fb">&#9670;&nbsp;</a></span>getRoundTripTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getRoundTripTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the time in milliseconds until a reliable command is acknowledged by the server.</dd></dl>
<p>This is, what is commonly called a ping time or just a ping. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#ace25d38b4d458e3dfb0b670ecd317682">getRoundTripTimeVariance()</a> </dd></dl>

</div>
</div>
<a id="ace25d38b4d458e3dfb0b670ecd317682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace25d38b4d458e3dfb0b670ecd317682">&#9670;&nbsp;</a></span>getRoundTripTimeVariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getRoundTripTimeVariance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the variance of the roundtrip time in milliseconds. Gives a hint about how much the net latency is varying. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a85101f9ea38bc642cb74ec4ae571b9fb">getRoundTripTime()</a> </dd></dl>

</div>
</div>
<a id="aea076259cd369fb751e50467adea2361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea076259cd369fb751e50467adea2361">&#9670;&nbsp;</a></span>getTimestampOfLastSocketReceive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getTimestampOfLastSocketReceive </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>timestamp of the last time anything (!) was received from the server (including low level Ping and ACKs but also events and operation-returns). This is not the time when something was dispatched. </dd></dl>

</div>
</div>
<a id="acee10207cc62f0fa06f3b8853621295a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee10207cc62f0fa06f3b8853621295a">&#9670;&nbsp;</a></span>getDebugOutputLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getDebugOutputLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Returns the current level of debug information that's passed on to <a class="el" href="a10714.html#a6fcf1232530518193479d1c38c916843">BaseListener::debugReturn()</a>. </p><dl class="section return"><dt>Returns</dt><dd>one of the values in DebugLevel </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a163e299695ce92d2f02eb4b78b29ab2b">setDebugOutputLevel()</a> </dd></dl>

</div>
</div>
<a id="a163e299695ce92d2f02eb4b78b29ab2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163e299695ce92d2f02eb4b78b29ab2b">&#9670;&nbsp;</a></span>setDebugOutputLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setDebugOutputLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>debugLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Sets the current level of debug information that's passed on to <a class="el" href="a10714.html#a6fcf1232530518193479d1c38c916843">BaseListener::debugReturn()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">debugLevel</td><td>one of the values in DebugLevel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the new debug level has been set correctly, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#acee10207cc62f0fa06f3b8853621295a">getDebugOutputLevel()</a> </dd></dl>

</div>
</div>
<a id="a61033342848847f071fa6d35aff19f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61033342848847f071fa6d35aff19f37">&#9670;&nbsp;</a></span>getLogFormatOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a11522.html">LogFormatOptions</a> &amp; getLogFormatOptions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section return"><dt>Returns</dt><dd>the LogFormatOptions that are used by this instance. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setFormatOptions() </dd></dl>

</div>
</div>
<a id="ae5f7c93e1c773e9369da96bb1e7dd2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f7c93e1c773e9369da96bb1e7dd2e3">&#9670;&nbsp;</a></span>setLogFormatOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setLogFormatOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a11522.html">Common::LogFormatOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>formatOptions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Sets the log format options to the supplied value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formatOptions</td><td>the new value to which the log format options will be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>getFormatOptions() </dd></dl>

</div>
</div>
<a id="a7493c7adc48661bc30026674de31d561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7493c7adc48661bc30026674de31d561">&#9670;&nbsp;</a></span>getIncomingReliableCommandsCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getIncomingReliableCommandsCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of reliable commands currently waiting in the incoming queues of all channels or -1 if not connected. </dd></dl>

</div>
</div>
<a id="a57ffbf998c2d43f7261e31a3858e3e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ffbf998c2d43f7261e31a3858e3e18">&#9670;&nbsp;</a></span>getPeerID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short getPeerID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>this peer's ID as assigned by the server. Will be -1, if not connected. </dd></dl>

</div>
</div>
<a id="acdda1b98b605e108ac6950d9c2d8ff3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdda1b98b605e108ac6950d9c2d8ff3b">&#9670;&nbsp;</a></span>getDisconnectTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getDisconnectTimeout </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum time interval in milliseconds for doing resend retries before a peer is considered lost/disconnected. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a9f9e8b780e386121f1b33b3f1c95c123">setDisconnectTimeout()</a> <a class="el" href="a11658.html#ac8e39d83514f8803df537245cf23db14">getSentCountAllowance()</a> <a class="el" href="a11658.html#a9a6f199c62967e857482a2e6ae0cd95d">setSentCountAllowance()</a> </dd></dl>

</div>
</div>
<a id="a9f9e8b780e386121f1b33b3f1c95c123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9e8b780e386121f1b33b3f1c95c123">&#9670;&nbsp;</a></span>setDisconnectTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDisconnectTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>disconnectTimeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the maximum time ins milliseconds for making re-send retries before a peer is considered lost/disconnected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disconnectTimeout</td><td>resend max time in ms before a peer is considered lost/disconnected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#acdda1b98b605e108ac6950d9c2d8ff3b">getDisconnectTimeout()</a> <a class="el" href="a11658.html#ac8e39d83514f8803df537245cf23db14">getSentCountAllowance()</a> <a class="el" href="a11658.html#a9a6f199c62967e857482a2e6ae0cd95d">setSentCountAllowance()</a> </dd></dl>

</div>
</div>
<a id="a82ca352fb9c22793bf6a1f534fd9eedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ca352fb9c22793bf6a1f534fd9eedb">&#9670;&nbsp;</a></span>getQueuedIncomingCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getQueuedIncomingCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of queued incoming commands in all channels or -1 if not connected </dd></dl>

</div>
</div>
<a id="a3173bc58e2727d71e30e6a44279aabcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3173bc58e2727d71e30e6a44279aabcd">&#9670;&nbsp;</a></span>getQueuedOutgoingCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getQueuedOutgoingCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of queued outgoing commands in all channels or -1 if not connected </dd></dl>

</div>
</div>
<a id="a66443de75b3ba8dee71726ef035b9146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66443de75b3ba8dee71726ef035b9146">&#9670;&nbsp;</a></span>getServerAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a11510.html">JString</a> getServerAddress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the IP or url of the server, to which the peer is connected to </dd></dl>

</div>
</div>
<a id="a128dedaab588e53ded9fd9b7708e140b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128dedaab588e53ded9fd9b7708e140b">&#9670;&nbsp;</a></span>getIsPayloadEncryptionAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getIsPayloadEncryptionAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>this peer's payload encryption availability status. True if payload encryption is available, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#abeb9753eb4af1ebe91f31d0015ee20f4">getIsEncryptionAvailable()</a>, <a class="el" href="a11658.html#a65ac22c1480ba011cf646db5a1038f63">establishEncryption()</a>, <a class="el" href="a11658.html#aa316328ce29a9de94bcc82b42ac1c220">initUserDataEncryption()</a> </dd></dl>

</div>
</div>
<a id="abeb9753eb4af1ebe91f31d0015ee20f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb9753eb4af1ebe91f31d0015ee20f4">&#9670;&nbsp;</a></span>getIsEncryptionAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getIsEncryptionAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>this peer's encryption availability status. True if either payload encryption is available or if the connection protocol is UDP and UDP encryption is available or if the connection protocol is already secure on its own, false otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a128dedaab588e53ded9fd9b7708e140b">getIsPayloadEncryptionAvailable()</a>, <a class="el" href="a11658.html#a65ac22c1480ba011cf646db5a1038f63">establishEncryption()</a>, <a class="el" href="a11658.html#aa316328ce29a9de94bcc82b42ac1c220">initUserDataEncryption()</a>, <a class="el" href="a11658.html#a78b99f5c56ea31f81e01cb1c95829ddf">initUDPEncryption()</a> </dd></dl>

</div>
</div>
<a id="aedf52333d72638f95904828d4abebdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf52333d72638f95904828d4abebdc4">&#9670;&nbsp;</a></span>getResentReliableCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getResentReliableCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the count of commands that got repeated (due to local repeat-timing before an ACK was received). </dd></dl>

</div>
</div>
<a id="a8e0ae75e5cbd27385fac17357795d239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0ae75e5cbd27385fac17357795d239">&#9670;&nbsp;</a></span>getLimitOfUnreliableCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getLimitOfUnreliableCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the limit for the queue of received unreliable commands. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a675a14def7ed1f13d8851c2c509fda44">setLimitOfUnreliableCommands()</a> </dd></dl>

</div>
</div>
<a id="a675a14def7ed1f13d8851c2c509fda44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675a14def7ed1f13d8851c2c509fda44">&#9670;&nbsp;</a></span>setLimitOfUnreliableCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setLimitOfUnreliableCommands </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the limit for the queue of received unreliable commands. This works only in UDP. This limit is applied when you call dispatchIncomingCommands. If this client (already) received more than this limit, it will throw away the older ones instead of dispatching them. This can produce bigger gaps for unreliable commands but your client catches up faster. This can be useful when the client couldn't dispatch anything for some time (cause it was in a room but loading a level). If set to 20, the incoming unreliable queues are truncated to 20. If 0, all received unreliable commands will be dispatched. This is a "per channel" value, so each channel can hold commands up to specified limit. This value interacts with <a class="el" href="a11658.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a>: If that is called less often, more commands get skipped. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a8e0ae75e5cbd27385fac17357795d239">getLimitOfUnreliableCommands()</a> </dd></dl>

</div>
</div>
<a id="aacd6583f9b6732f5217b69de3016ef8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd6583f9b6732f5217b69de3016ef8d">&#9670;&nbsp;</a></span>getCRCEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getCRCEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if CRC enabled </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a86720f73f3549fe7cec3c48aaaed2dea">setCRCEnabled</a> </dd></dl>

</div>
</div>
<a id="a86720f73f3549fe7cec3c48aaaed2dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86720f73f3549fe7cec3c48aaaed2dea">&#9670;&nbsp;</a></span>setCRCEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setCRCEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>crcEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables or disables CRC. While not connected, this controls if the next connection(s) should use a per-package CRC checksum. If the client is in another state than 'connected', then this function has no effect except for logging an error.</p>
<p>While turned on, the client and server will add a CRC checksum to every sent package. The checksum enables both sides to detect and ignore packages that were corrupted during transfer. Corrupted packages have the same impact as lost packages: They require a re-send, adding a delay and could lead to timeouts. Building the checksum has a low processing overhead but increases integrity of sent and received data. Packages discarded due to failed CRC checks are counted in PhotonPeer.PacketLossByCRC. </p><dl class="section note"><dt>Note</dt><dd>This only has effect for UDP connections. </dd>
<dd>
This does not have any effect for connections that use UDP datagram encryption (which always use a built-in checksum). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#aacd6583f9b6732f5217b69de3016ef8d">getCRCEnabled</a> </dd></dl>

</div>
</div>
<a id="ac21ce2fab19a7f89371b55b80e9a6104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21ce2fab19a7f89371b55b80e9a6104">&#9670;&nbsp;</a></span>getPacketLossByCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getPacketLossByCRC </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the count of packages dropped due to failed CRC checks for this connection. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a11658.html#a86720f73f3549fe7cec3c48aaaed2dea">setCRCEnabled</a> </dd></dl>

</div>
</div>
<a id="a63818ef2534cb686799ba4b8089d87b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63818ef2534cb686799ba4b8089d87b1">&#9670;&nbsp;</a></span>getTrafficStatsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getTrafficStatsEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if traffic statistics of a peer are enabled. Default trafficStatsEnabled: false (disabled). </dd></dl>

</div>
</div>
<a id="a205ce7c707be94fea1fa0991b5591e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205ce7c707be94fea1fa0991b5591e7c">&#9670;&nbsp;</a></span>setTrafficStatsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setTrafficStatsEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trafficStatsEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables or disables the traffic statistics of a peer. Default trafficStatsEnabled: false (disabled). </p>

</div>
</div>
<a id="aa9fd6df74699a45931166b13b8473969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fd6df74699a45931166b13b8473969">&#9670;&nbsp;</a></span>getTrafficStatsElapsedMs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getTrafficStatsElapsedMs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the count of milliseconds the stats are enabled for tracking. </dd></dl>

</div>
</div>
<a id="a5f9db711d733ea73b6bcbb49c9dca431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9db711d733ea73b6bcbb49c9dca431">&#9670;&nbsp;</a></span>getTrafficStatsIncoming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a11674.html">TrafficStats</a> &amp; getTrafficStatsIncoming </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the byte-count of incoming "low level" messages, which are either Enet Commands or TCP Messages. These include all headers, except those of the underlying internet protocol UDP or TCP. </dd></dl>

</div>
</div>
<a id="afef71b634eb9c5206e7ee625b65a34f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef71b634eb9c5206e7ee625b65a34f6">&#9670;&nbsp;</a></span>getTrafficStatsOutgoing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a11674.html">TrafficStats</a> &amp; getTrafficStatsOutgoing </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the byte-count of outgoing "low level" messages, which are either Enet Commands or TCP Messages. These include all headers, except those of the underlying internet protocol UDP or TCP. </dd></dl>

</div>
</div>
<a id="a98257fc026ad5d7863a5692d1de91769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98257fc026ad5d7863a5692d1de91769">&#9670;&nbsp;</a></span>getTrafficStatsGameLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a11678.html">TrafficStatsGameLevel</a> &amp; getTrafficStatsGameLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a statistic of incoming and outgoing traffic, split by operation, operation-result and event. Operations are outgoing traffic, results and events are incoming. Includes the per-command header sizes (UDP: Enet Command Header or TCP: Message Header). </dd></dl>

</div>
</div>
<a id="adb2b890f4b3dd79360358b3afaffd9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2b890f4b3dd79360358b3afaffd9e8">&#9670;&nbsp;</a></span>getQuickResendAttempts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nByte getQuickResendAttempts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of resend attempts for a reliable command that are done in quick succession (after RoundTripTime+4*RoundTripTimeVariance). </dd></dl>

</div>
</div>
<a id="a2a43056816067b306fc0feb54bcd97f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a43056816067b306fc0feb54bcd97f5">&#9670;&nbsp;</a></span>setQuickResendAttempts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setQuickResendAttempts </td>
          <td>(</td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>quickResendAttempts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the number of resend attempts for a reliable command can be done in quick succession (after RoundTripTime+4*RoundTripTimeVariance). </p><dl class="section remark"><dt>Remarks</dt><dd>The default value is 0. Any later resend attempt will then double the time before the next resend takes place. The max value is 4. Make sure to set SentCountAllowance to a slightly higher value, as more repeats will get done. </dd></dl>

</div>
</div>
<a id="ab08cedfa555dddb5394a000a5ede9079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08cedfa555dddb5394a000a5ede9079">&#9670;&nbsp;</a></span>getConnectionProtocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nByte getConnectionProtocol </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the currently set connection protocol. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The value returned is not guaranteed to be the value used for the currently active connection, but only the value that has last been passed to <a class="el" href="a11658.html#a5f3ba3c7b9229c180cbcbe5de35ed77a">setConnectionProtocol()</a>. The reason therefor is that whatever you pass to <a class="el" href="a11658.html#a5f3ba3c7b9229c180cbcbe5de35ed77a">setConnectionProtocol()</a> won't take effect until you re-connect. </dd></dl>

</div>
</div>
<a id="a5f3ba3c7b9229c180cbcbe5de35ed77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3ba3c7b9229c180cbcbe5de35ed77a">&#9670;&nbsp;</a></span>setConnectionProtocol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setConnectionProtocol </td>
          <td>(</td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>connectionProtocol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the connection protocol to be used with the next <a class="el" href="a11658.html#a350712dc9e140a7368a950d46f16ea56">connect()</a> call. </p><dl class="section note"><dt>Note</dt><dd>This does not have any effect on the protocol that is used for an already active connection. So you need to re-connect after setting a different connection protocol for the changes to actually take effect. </dd></dl>

</div>
</div>
<a id="a1b8dacd122e7d5ebaeee1f309a2858b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8dacd122e7d5ebaeee1f309a2858b8">&#9670;&nbsp;</a></span>getChannelCountUserChannels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">nByte getChannelCountUserChannels </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The IDs from 0 to <a class="el" href="a11658.html#a1b8dacd122e7d5ebaeee1f309a2858b8">getChannelCountUserChannels()</a>-1 can be passed as channelID to operations that offer this parameter. </p><dl class="section return"><dt>Returns</dt><dd>the number of different channels that are available for sending operations on. </dd></dl>

</div>
</div>
<a id="a10359924120048ca6281db6ed9dda97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10359924120048ca6281db6ed9dda97d">&#9670;&nbsp;</a></span>getPeerCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short getPeerCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the count of peers, which have been initialized since the start of the application. Interesting mainly for debugging purposes. </dd></dl>

</div>
</div>
<a id="a188320d3f17c777953e635ee225d735b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188320d3f17c777953e635ee225d735b">&#9670;&nbsp;</a></span>getMaxAppIDLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int getMaxAppIDLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum allowed length for the appID that gets passed to <a class="el" href="a11658.html#a350712dc9e140a7368a950d46f16ea56">connect()</a> in characters </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<footer style="border-top: 1px solid #444; margin-top: 1em; padding: 1em;">
    <div style="float: left;">
        &copy;&nbsp;<a href="https://www.photonengine.com/"> Exit Games &reg;</a>, all rights reserved.
    </div>
    <div style="float: right;">
        <a href="http://doc.photonengine.com/">Photon Documentation</a> |
        <a href="http://www.photonengine.com/en/contact">Contact</a> |
        <a href="https://www.photonengine.com/en/account/terms">Terms</a>
    <div>
    <b style="clear: both;"></b>
</footer>
<script>
  (function() {
    var cx = '015653142792304683059:ykdoyzkcyu4';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
</body>
</html>