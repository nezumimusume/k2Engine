<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="UTF-8" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="generator" content="Doxygen 1.8.17"/>
    <meta name="addsearch-custom-field" content="product=realtime"/>
    <meta name="addsearch-custom-field" content="version=current"/>
    <meta name="addsearch-category" content="realtime/current" />
    <title>Photon C++ Client API: ExitGames::Common::MemoryManagement Namespace Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link rel="alternate" type="text/xml" title="RSS" href="http://feeds.feedburner.com/exitgamesphoton">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="http://feeds.feedburner.com/exitgamesphoton">
    <!-- For IE: -->
    <link rel="shortcut icon" href="/favicon.ico" type="image/vnd.microsoft.icon">
    <!-- For Browsers, Android: -->
    <link rel="icon" sizes="192x192" href="/touch-icon-192x192.png">
    <link rel="icon" sizes="57x57" href="/apple-touch-icon-precomposed.png">
    <!-- For iPhone 6 Plus: -->
    <link rel="apple-touch-icon-precomposed" sizes="180x180" href="/apple-touch-icon-180x180-precomposed.png">
    <!-- For iPad running iOS = 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/apple-touch-icon-152x152-precomposed.png">
    <!-- For iPhone running iOS = 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/apple-touch-icon-120x120-precomposed.png">
    <!-- For the iPad mini and the first- and second-generation iPad on iOS = 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/apple-touch-icon-76x76-precomposed.png">
    <!-- For non-Retina iPhone, iPod Touch, and Android 2.1+ devices: -->
    <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png">
    <style>
        @charset "UTF-8";
        @import url(//fonts.googleapis.com/css?family=Open+Sans:300,600,700);
        html,
        body {
            height: 100.1%;
        }
        body {
            font-family: "Open Sans", Verdana, Helvetica, Arial, sans-serif;
            line-height: 1.51803398875;
                -webkit-font-smoothing: antialiased;
                -webkit-text-size-adjust: 100%;
            text-rendering: optimizeLegibility;
        }
        #projectname { font-size: 200%; }
        #projectname img {
            vertical-align: sub;
            margin-right: .2em;
        }
    </style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <table cellspacing="0" cellpadding="0" style="width: 100%;">
        <tbody>
            <tr style="height: 56px;">
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">
                        <img alt="" src="logo.png">
                        Photon C++ Client API
                    &#160;<span id="projectnumber">5.0.0.0</span>
                    </div>
                </td>
                <td style="width: 50%;"><gcse:search linktarget="_parent"></gcse:search></td>
            </tr>
        </tbody>
    </table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a10622.html">ExitGames</a></li><li class="navelem"><a class="el" href="a10623.html">Common</a></li><li class="navelem"><a class="el" href="a10632.html">MemoryManagement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ExitGames::Common::MemoryManagement Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11538.html">AllocatorInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a887a196a42f08e0f7fa136cc4c8ade5e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a10632.html#a887a196a42f08e0f7fa136cc4c8ade5e">EG_MALLOC</a> (size_t size)</td></tr>
<tr class="separator:a887a196a42f08e0f7fa136cc4c8ade5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e88070c94d33012ef229a6bd5cd141b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a10632.html#a5e88070c94d33012ef229a6bd5cd141b">EG_FREE</a> (void *p)</td></tr>
<tr class="separator:a5e88070c94d33012ef229a6bd5cd141b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab816ce0306f8d6409585afd846dc606f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a10632.html#ab816ce0306f8d6409585afd846dc606f">EG_REALLOC</a> (void *p, size_t size)</td></tr>
<tr class="separator:ab816ce0306f8d6409585afd846dc606f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97992c7f9f82e99b3c1825f2ceaf335"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a10632.html#ab97992c7f9f82e99b3c1825f2ceaf335">EG_CALLOC</a> (size_t num, size_t size)</td></tr>
<tr class="separator:ab97992c7f9f82e99b3c1825f2ceaf335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d3477e25c4020f87ae6a4399520028"><td class="memItemLeft" align="right" valign="top"><a id="a52d3477e25c4020f87ae6a4399520028"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((weak)) <a class="el" href="a11538.html">AllocatorInterface</a> *<a class="el" href="a11538.html">AllocatorInterface</a></td></tr>
<tr class="separator:a52d3477e25c4020f87ae6a4399520028"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
HighLevelMemoryManagement</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp987d2ce4943415b6afea28ef1a2dd82c"></a><a class="anchor" id="HighLevelMemoryManagement"></a> The template functions in this section are an alternative for the C++ dynamic memory management operators new, new[], delete and delete[].</p>
<p>They are implemented in terms of enhancing the <a class="el" href="D:/a/Windows/Common-cpp/inc/MemoryManagement/Allocate.h#LowLevelMemoryManagement">Low Level Memory Management macros</a> and for this reason offer similar advantages over new and co like those macros offer over malloc and co.</p>
<p>However same as new and co they also construct and destruct the objects that they allocate and deallocate. </p>
</td></tr>
<tr class="memitem:ab22cc6204c311be2fd3ade76452b15fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a10632.html#ab22cc6204c311be2fd3ade76452b15fc">setMaxAllocSize</a> (size_t maxAllocSize)</td></tr>
<tr class="separator:ab22cc6204c311be2fd3ade76452b15fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab357617986b2b7fdda30558ddd1fe3cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a10632.html#ab357617986b2b7fdda30558ddd1fe3cd">setMaxSizeForAllocatorUsage</a> (size_t maxSizeForAllocatorUsage)</td></tr>
<tr class="separator:ab357617986b2b7fdda30558ddd1fe3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9ca1c31b7e751410dfa14807176672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">setAllocator</a> (<a class="el" href="a11538.html">ExitGames::Common::MemoryManagement::AllocatorInterface</a> &amp;allocator)</td></tr>
<tr class="separator:ada9ca1c31b7e751410dfa14807176672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379196b09e74bed85dbeca2c0f600af1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a10632.html#a379196b09e74bed85dbeca2c0f600af1">setAllocatorToDefault</a> (void)</td></tr>
<tr class="separator:a379196b09e74bed85dbeca2c0f600af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cf44f20d4f0fec53dc2bad59ea6f66"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:af9cf44f20d4f0fec53dc2bad59ea6f66"><td class="memTemplItemLeft" align="right" valign="top">Ftype *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a10632.html#af9cf44f20d4f0fec53dc2bad59ea6f66">allocate</a> (void)</td></tr>
<tr class="separator:af9cf44f20d4f0fec53dc2bad59ea6f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01d00409131f2befd3035878f5816ce"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:ac01d00409131f2befd3035878f5816ce"><td class="memTemplItemLeft" align="right" valign="top">Ftype *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a10632.html#ac01d00409131f2befd3035878f5816ce">allocateArray</a> (size_t count)</td></tr>
<tr class="separator:ac01d00409131f2befd3035878f5816ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8faeae987370e81dcdac42041207d5"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:aad8faeae987370e81dcdac42041207d5"><td class="memTemplItemLeft" align="right" valign="top">Ftype *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a10632.html#aad8faeae987370e81dcdac42041207d5">reallocateArray</a> (Ftype *p, size_t count)</td></tr>
<tr class="separator:aad8faeae987370e81dcdac42041207d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab0c26ccee7949cb30a976e74be459b"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:adab0c26ccee7949cb30a976e74be459b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a10632.html#adab0c26ccee7949cb30a976e74be459b">deallocate</a> (const Ftype *p)</td></tr>
<tr class="separator:adab0c26ccee7949cb30a976e74be459b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a9af6035370cc6bbcae6d6d3f358e5"><td class="memTemplParams" colspan="2">template&lt;typename Ftype &gt; </td></tr>
<tr class="memitem:a93a9af6035370cc6bbcae6d6d3f358e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a10632.html#a93a9af6035370cc6bbcae6d6d3f358e5">deallocateArray</a> (const Ftype *p)</td></tr>
<tr class="separator:a93a9af6035370cc6bbcae6d6d3f358e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="a10632.html">MemoryManagement</a> </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a887a196a42f08e0f7fa136cc4c8ade5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887a196a42f08e0f7fa136cc4c8ade5e">&#9670;&nbsp;</a></span>EG_MALLOC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * EG_MALLOC </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro allocates the requested amount of bytes as a single continuous block from dynamic memory and returns the address of the first byte of that block.</p>
<p>Blocks of memory that have been allocated with <a class="el" href="a10632.html#a887a196a42f08e0f7fa136cc4c8ade5e">EG_MALLOC()</a>, have to be deallocated with <a class="el" href="a10632.html#a5e88070c94d33012ef229a6bd5cd141b">EG_FREE()</a>, when they are no longer needed.</p>
<p>If the requested amount of bytes is 0, then this macro will do nothing and return a NULL pointer. </p>

</div>
</div>
<a id="a5e88070c94d33012ef229a6bd5cd141b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e88070c94d33012ef229a6bd5cd141b">&#9670;&nbsp;</a></span>EG_FREE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EG_FREE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pass the address of memory, that has previously been returned by <a class="el" href="a10632.html#a887a196a42f08e0f7fa136cc4c8ade5e">EG_MALLOC()</a>, <a class="el" href="a10632.html#ab816ce0306f8d6409585afd846dc606f">EG_REALLOC()</a> or <a class="el" href="a10632.html#ab97992c7f9f82e99b3c1825f2ceaf335">EG_CALLOC()</a> to this function, to deallocate it.</p>
<p>If the passed address is NULL, then this macro will do nothing.</p>
<p>If a passed non-NULL address was not previously returned by <a class="el" href="a10632.html#a887a196a42f08e0f7fa136cc4c8ade5e">EG_MALLOC()</a>, <a class="el" href="a10632.html#ab816ce0306f8d6409585afd846dc606f">EG_REALLOC()</a> or <a class="el" href="a10632.html#ab97992c7f9f82e99b3c1825f2ceaf335">EG_CALLOC()</a>, then the behavior is undefined. </p>

</div>
</div>
<a id="ab816ce0306f8d6409585afd846dc606f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab816ce0306f8d6409585afd846dc606f">&#9670;&nbsp;</a></span>EG_REALLOC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * EG_REALLOC </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro resizes the block of memory at the passed address to the passed size and returns the new address of this block of memory.</p>
<p>The returned address isn't guaranteed to match the passed one. Depending on the old and new size of the memory block, resizing the block may include moving it to a new location. When a block gets moved, is an implementation detail, that could be different between implementations on different platforms and can change without notice. Notably block-movements might happen in the case of an increase as well as of a decrease of the block size.</p>
<p>If a block of memory gets moved to a new location, then the content of all bytes that fit in both, the old and the new block size, is copied from the old to the new location by a call to memcpy(). For this reason calls to <a class="el" href="a10632.html#ab816ce0306f8d6409585afd846dc606f">EG_REALLOC()</a> can be expensive for huge blocks of memory.</p>
<p>If the new block size is smaller than the old one, then all content at the surplus bytes will get lost.</p>
<p>If the passed address is NULL, then this macro will behave just like <a class="el" href="a10632.html#a887a196a42f08e0f7fa136cc4c8ade5e">EG_MALLOC()</a>.</p>
<p>If a passed non-NULL address was not previously returned by <a class="el" href="a10632.html#a887a196a42f08e0f7fa136cc4c8ade5e">EG_MALLOC()</a>, <a class="el" href="a10632.html#ab816ce0306f8d6409585afd846dc606f">EG_REALLOC()</a> or <a class="el" href="a10632.html#ab97992c7f9f82e99b3c1825f2ceaf335">EG_CALLOC()</a>, then the behavior is undefined. </p>

</div>
</div>
<a id="ab97992c7f9f82e99b3c1825f2ceaf335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97992c7f9f82e99b3c1825f2ceaf335">&#9670;&nbsp;</a></span>EG_CALLOC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * EG_CALLOC </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This macro allocates memory for the requested amount of array elements of the specified element size as a single continuous block from dynamic memory, initializes all its bytes to 0 and returns the address of the first byte of that block.</p>
<p>Blocks of memory that have been allocated with <a class="el" href="a10632.html#ab97992c7f9f82e99b3c1825f2ceaf335">EG_CALLOC()</a>, have to be deallocated with <a class="el" href="a10632.html#a5e88070c94d33012ef229a6bd5cd141b">EG_FREE()</a>, when they are no longer needed.</p>
<p>If the requested amount of bytes is 0, then this macro will do nothing and return a NULL pointer. </p>

</div>
</div>
<a id="ab22cc6204c311be2fd3ade76452b15fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22cc6204c311be2fd3ade76452b15fc">&#9670;&nbsp;</a></span>setMaxAllocSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMaxAllocSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxAllocSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the max size of memory that might get allocated ahead of time as a result of a single memory request.</p>
<p>Requesting memory from the OS is an expensive operation. This is why a good memory manager might choose to request bigger amounts of memory at once and give out smaller chunks of them to the application code. This way it can reduce the amount of necessary memory requests to the OS. Depending on the memory requests that come in from the application code, a memory manager might decide to scale up its own requests to the OS.</p>
<p>You can set an upper limit for how much the currently active memory manager is allowed to scale up through this function.</p>
<p>Example: Consider a pool-based memory manager that uses multiple memory pools, where each serves requests for memory of different sizes. There could be a pool for tiny memory requests, one for small requests, one for medium requests, and so on.</p>
<p>Now let's imagine that there is a pool that serves requests between 65 and 128 bytes in size each and for this purpose keeps a bunch of 128 byte blocks around to give out to requesters. In the beginning it might just keep very few such blocks around, as the memory manager does not know, how many blocks of this size an app might need to use in parallel. When an app requests lots of those blocks, the pool would scale accordingly and to not need to do a request to the OS too often, it might increase the size of it's own requests. i.e. at first it could have just 4 blocks around, then when it resizes, it would allocate memory for another 4 blocks, then for 8 more, then for another, 16, then 32, 64, 128, 256, 512, 1024 blocks more, and so on.</p>
<p>Now if you set an upper limit of 8192 bytes, then the pool would not increase the size of its requests to the OS beyond that limit. For that 128 byte blocks pool that would mean that it would request at max 8192/128==64 blocks at once. So the resize pattern from above would change to 4, 8, 16, 32, 64, 64, 64, 64, and so on.</p>
<p>Accordingly with the same 8192 bytes limit in place a pool that holds 1024 byte blocks would not allocate memory for more than 8 such blocks at once. </p><dl class="section note"><dt>Note</dt><dd>This does not set a limit to the overall memory that might get allocated, but only to the memory that gets allocated as a direct result of a single memory request. The very next request might already lead to another allocation if the memory manager decides so (for example a pool based memory manager might serve differently sized requests from different pools that resize independently from each other). </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function forwards the passed in value to the currently set allocator (see <a class="el" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">setAllocator()</a> ) and does not store it itself. For this reason a call to this function only affects the settings of the currently set allocator and not those of any future allocator, that might be set by <a class="el" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">setAllocator()</a> at any point in time after this function got called. </dd>
<dd>
It is the responsibility of the allocator to honor the setting that the user has applied through this function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxAllocSize</td><td>the max size for a single memory request to the OS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">setAllocator()</a>, <a class="el" href="a11538.html">AllocatorInterface</a> </dd></dl>

</div>
</div>
<a id="ab357617986b2b7fdda30558ddd1fe3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab357617986b2b7fdda30558ddd1fe3cd">&#9670;&nbsp;</a></span>setMaxSizeForAllocatorUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMaxSizeForAllocatorUsage </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSizeForAllocatorUsage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a limit up to which memory requests get forwarded to the set allocator. Requests with a size above the limit get redirected to the OS instead.</p>
<p>Requesting memory from the OS is an expensive operation.</p>
<p>For frequent requests of small amounts of memory it is usually more efficient to request that memory from a memory manager instead, which requests bigger amounts of memory from the OS at once, splits them up into smaller blocks and returns those smaller blocks to the requester.</p>
<p>However this is effectively a trade of reduced execution time bought with increased memory usage, which is usually a good deal for frequent small requests, but a bad deal for infrequent requests of bigger amounts of memory.</p>
<p>For this reason from a certain request size on requests get forwarded directly to the OS instead of to the set allocator.</p>
<p>This function lets you set the upper limit up to which the set allocator is used.</p>
<p>Requests above the limit will be forwarded directly to the OS. </p><dl class="section remark"><dt>Remarks</dt><dd>The value that is set through this function affects all allocators, not just the currently set one. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxSizeForAllocatorUsage</td><td>the max size for a memory request up to which the set allocator gets used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">setAllocator()</a>, <a class="el" href="a11538.html">AllocatorInterface</a> </dd></dl>

</div>
</div>
<a id="ada9ca1c31b7e751410dfa14807176672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9ca1c31b7e751410dfa14807176672">&#9670;&nbsp;</a></span>setAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a11538.html">ExitGames::Common::MemoryManagement::AllocatorInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the allocator that will be used by future memory requests to the provided value.</p>
<p>All dynamic memory allocation requests by the Photon Client libraries go either through one of functions in <a class="el" href="a10632.html">MemoryManagement</a> or through one of the <a class="el" href="D:/a/Windows/Common-cpp/inc/MemoryManagement/Allocate.h#LowLevelMemoryManagement">Low Level Memory Management macros</a>. The application code can also use these functions and macros for its own memory requests if its developer chooses so.</p>
<p>Each request for an amount of memory that does not exceed the limit set by <a class="el" href="a10632.html#ab357617986b2b7fdda30558ddd1fe3cd">setMaxSizeForAllocatorUsage()</a> gets forwarded to an allocator. Photon provides a default general-purpose allocator that uses pool based memory management and that works well for most applications.</p>
<p>However you can set your own allocator through this function and Photon will use that allocator for any memory requests that happen afterwards.</p>
<p>Regarding potential reasons for writing your own custom allocator please see <a href="https://en.wikipedia.org/wiki/Allocator_(C%2B%2B)#Custom_allocators">https://en.wikipedia.org/wiki/Allocator_(C%2B%2B)#Custom_allocators</a>. </p><dl class="section remark"><dt>Remarks</dt><dd>Photons memory management stores the address of the allocator that served a specific memory request and forwards a request to free memory to the same allocator that allocated that memory. </dd>
<dd>
This means a) that you can set a different allocator as often as you like at any point in time you like and b) that you need to keep any once set allocator available even when it is no longer set as the currently used allocator, at least until you can guarantee that all memory that once got requested from it, got returned to it and non of it is still in use. </dd>
<dd>
If you want to already set an initial custom allocator before any global or file-level static instances of Photon classes get constructed, then you need to replace <a class="el" href="a11538.html#a14ba1258bf4a2a6114a52dbf7291c75a">AllocatorInterface::get()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>an instance of a subclass of <a class="el" href="a11538.html">AllocatorInterface</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a10632.html#ab357617986b2b7fdda30558ddd1fe3cd">setMaxSizeForAllocatorUsage()</a>, <a class="el" href="a11538.html">AllocatorInterface</a>, <a class="el" href="a11538.html#a14ba1258bf4a2a6114a52dbf7291c75a">AllocatorInterface::get()</a> </dd></dl>

</div>
</div>
<a id="a379196b09e74bed85dbeca2c0f600af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379196b09e74bed85dbeca2c0f600af1">&#9670;&nbsp;</a></span>setAllocatorToDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setAllocatorToDefault </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls <a class="el" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">setAllocator()</a> with Photons default allocator as parameter. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">setAllocator()</a> </dd></dl>

</div>
</div>
<a id="af9cf44f20d4f0fec53dc2bad59ea6f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cf44f20d4f0fec53dc2bad59ea6f66">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ftype* ExitGames::Common::MemoryManagement::allocate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function allocates a new instance of the type, that has been specified as first template parameter, on dynamic memory and properly initializes it. For an instance of a class type this includes calling a constructor on the instance.</p>
<p>Instances, that have been allocated with <a class="el" href="a10632.html#af9cf44f20d4f0fec53dc2bad59ea6f66">allocate()</a>, have to be deallocated with <a class="el" href="a10632.html#adab0c26ccee7949cb30a976e74be459b">deallocate()</a>, when they are no longer needed.</p>
<p>Up to 5 optional arguments can be passed to <a class="el" href="a10632.html#af9cf44f20d4f0fec53dc2bad59ea6f66">allocate()</a> and <a class="el" href="a10632.html#af9cf44f20d4f0fec53dc2bad59ea6f66">allocate()</a> will call a constructor with the matching number of parameters and matching parameter types. If the class of the object that is to be constructed, doesn't provide a constructor with a matching signature, if that constructor isn't publicly accessible or if it is ambiguous, which constructor to choose, then the call to <a class="el" href="a10632.html#af9cf44f20d4f0fec53dc2bad59ea6f66">allocate()</a> will trigger an error from the compiler.</p>
<p>The allocation is implemented via a call to <a class="el" href="a10632.html#a887a196a42f08e0f7fa136cc4c8ade5e">EG_MALLOC()</a>. </p>

</div>
</div>
<a id="ac01d00409131f2befd3035878f5816ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01d00409131f2befd3035878f5816ce">&#9670;&nbsp;</a></span>allocateArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ftype* ExitGames::Common::MemoryManagement::allocateArray </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function allocates an array of new instances of the type, that has been specified as first template parameter, on dynamic memory and properly initializes all of them. For arrays of class types this includes constructing each element via a constructor with matching parameter list.</p>
<p>Instances, that have been allocated with <a class="el" href="a10632.html#ac01d00409131f2befd3035878f5816ce">allocateArray()</a>, have to be deallocated with <a class="el" href="a10632.html#a93a9af6035370cc6bbcae6d6d3f358e5">deallocateArray()</a>, when they are no longer needed.</p>
<p>The passed element count is allowed to be 0. In that case this function still allocates storage to store the element count of 0 in, so the returned address still has to be deallocated later.</p>
<p>Up to 5 optional arguments can be passed to <a class="el" href="a10632.html#ac01d00409131f2befd3035878f5816ce">allocateArray()</a> and <a class="el" href="a10632.html#ac01d00409131f2befd3035878f5816ce">allocateArray()</a> will call a constructor with the matching number of parameters and matching parameter types. If the class of the elements that are to be constructed, doesn't provide a constructor with a matching signature, if that constructor isn't publicly accessible or if it is ambiguous, which constructor to choose, then the call to <a class="el" href="a10632.html#ac01d00409131f2befd3035878f5816ce">allocateArray()</a> will trigger an error from the compiler.</p>
<p>The allocation is implemented via a call to <a class="el" href="a10632.html#a887a196a42f08e0f7fa136cc4c8ade5e">EG_MALLOC()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>the amount of elements that the new array should have </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad8faeae987370e81dcdac42041207d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8faeae987370e81dcdac42041207d5">&#9670;&nbsp;</a></span>reallocateArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ftype* ExitGames::Common::MemoryManagement::reallocateArray </td>
          <td>(</td>
          <td class="paramtype">Ftype *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function resizes an array, that has previously been allocated with <a class="el" href="a10632.html#ac01d00409131f2befd3035878f5816ce">allocateArray()</a>.</p>
<p>The function allocates a new array of the same type as the provided one, but with the requested element count. Afterwards it copies all elements of the old array that fit into the new array into the new array by calling the copy constructor of the class of the elements.</p>
<p>If the new element count is lower than the old one, then the corresponding elements at the end of the old array don't get copied over to the new one, but are just destructed.</p>
<p>If the new requested element count is higher than the old one, then the remaining uninitialized elements in the new array get constructed by choosing the constructor that matches the provided optional arguments to <a class="el" href="a10632.html#aad8faeae987370e81dcdac42041207d5">reallocateArray()</a> best (no optional arguments means the default constructor gets called).</p>
<p>Finally the old array gets deallocated via <a class="el" href="a10632.html#a93a9af6035370cc6bbcae6d6d3f358e5">deallocateArray()</a> and the new array gets returned.</p>
<p>The returned address will most likely not match the passed one.</p>
<p>The passed address is allowed to be NULL. In that case this function behaves likes <a class="el" href="a10632.html#ac01d00409131f2befd3035878f5816ce">allocateArray()</a>.</p>
<p>The passed element count is allowed to be 0. In that case this function still allocates storage to store the element count of 0 in, so the returned address still has to be deallocated later.</p>
<p>If the passed address has not previously been returned by a call to <a class="el" href="a10632.html#ac01d00409131f2befd3035878f5816ce">allocateArray()</a> or <a class="el" href="a10632.html#aad8faeae987370e81dcdac42041207d5">reallocateArray()</a> and also isn't NULL or if it has already been passed to <a class="el" href="a10632.html#a93a9af6035370cc6bbcae6d6d3f358e5">deallocateArray()</a>, then the behavior is undefined.</p>
<p>Up to 5 optional arguments can be passed to <a class="el" href="a10632.html#aad8faeae987370e81dcdac42041207d5">reallocateArray()</a> and <a class="el" href="a10632.html#aad8faeae987370e81dcdac42041207d5">reallocateArray()</a> will call a constructor with the matching number of parameters and matching parameter types on each element of the new array, which hasn't already been copy-constructed from the corresponding element in the old array. If the class of the elements that are to be constructed, doesn't provide a constructor with a matching signature or if it doesn't provide a copy constructor, if that constructor or copy constructor isn't publicly accessible or if it is ambiguous, which constructor to choose, then the call to <a class="el" href="a10632.html#aad8faeae987370e81dcdac42041207d5">reallocateArray()</a> will trigger an error from the compiler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the address of the array, that is to be resized </td></tr>
    <tr><td class="paramname">count</td><td>the new amount of elements that the array should have </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adab0c26ccee7949cb30a976e74be459b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab0c26ccee7949cb30a976e74be459b">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ExitGames::Common::MemoryManagement::deallocate </td>
          <td>(</td>
          <td class="paramtype">const Ftype *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call this function to destruct and deallocate an instance, that has previously been allocated and constructed by a call to <a class="el" href="a10632.html#af9cf44f20d4f0fec53dc2bad59ea6f66">allocate()</a>.</p>
<p>The passed address is allowed to be NULL. In that case the call doesn't have any effect.</p>
<p>If the passed adress has not previously been returned by a call to <a class="el" href="a10632.html#af9cf44f20d4f0fec53dc2bad59ea6f66">allocate()</a> and also isn't NULL, then the behavior is undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the address of the instance, that should be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93a9af6035370cc6bbcae6d6d3f358e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a9af6035370cc6bbcae6d6d3f358e5">&#9670;&nbsp;</a></span>deallocateArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ExitGames::Common::MemoryManagement::deallocateArray </td>
          <td>(</td>
          <td class="paramtype">const Ftype *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call this function to destruct and deallocate an array, that has previously been allocated and constructed by a call to <a class="el" href="a10632.html#ac01d00409131f2befd3035878f5816ce">allocateArray()</a>.</p>
<p>This function will call their destructor on all elements of the array and then deallocate the memory of the array.</p>
<p>The passed address is allowed to be NULL. In that case the call doesn't have any effect.</p>
<p>If the passed adress has not previously been returned by a call to <a class="el" href="a10632.html#ac01d00409131f2befd3035878f5816ce">allocateArray()</a> or <a class="el" href="a10632.html#aad8faeae987370e81dcdac42041207d5">reallocateArray()</a> and also isn't NULL, then the behavior is undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the address of the array, that should be deallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<footer style="border-top: 1px solid #444; margin-top: 1em; padding: 1em;">
    <div style="float: left;">
        &copy;&nbsp;<a href="https://www.photonengine.com/"> Exit Games &reg;</a>, all rights reserved.
    </div>
    <div style="float: right;">
        <a href="http://doc.photonengine.com/">Photon Documentation</a> |
        <a href="http://www.photonengine.com/en/contact">Contact</a> |
        <a href="https://www.photonengine.com/en/account/terms">Terms</a>
    <div>
    <b style="clear: both;"></b>
</footer>
<script>
  (function() {
    var cx = '015653142792304683059:ykdoyzkcyu4';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
</body>
</html>