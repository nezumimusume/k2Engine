<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="UTF-8" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="generator" content="Doxygen 1.8.17"/>
    <meta name="addsearch-custom-field" content="product=realtime"/>
    <meta name="addsearch-custom-field" content="version=current"/>
    <meta name="addsearch-category" content="realtime/current" />
    <title>Photon C++ Client API: AllocatorInterface Class Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link rel="alternate" type="text/xml" title="RSS" href="http://feeds.feedburner.com/exitgamesphoton">
    <link rel="alternate" type="application/atom+xml" title="Atom" href="http://feeds.feedburner.com/exitgamesphoton">
    <!-- For IE: -->
    <link rel="shortcut icon" href="/favicon.ico" type="image/vnd.microsoft.icon">
    <!-- For Browsers, Android: -->
    <link rel="icon" sizes="192x192" href="/touch-icon-192x192.png">
    <link rel="icon" sizes="57x57" href="/apple-touch-icon-precomposed.png">
    <!-- For iPhone 6 Plus: -->
    <link rel="apple-touch-icon-precomposed" sizes="180x180" href="/apple-touch-icon-180x180-precomposed.png">
    <!-- For iPad running iOS = 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/apple-touch-icon-152x152-precomposed.png">
    <!-- For iPhone running iOS = 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/apple-touch-icon-120x120-precomposed.png">
    <!-- For the iPad mini and the first- and second-generation iPad on iOS = 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/apple-touch-icon-76x76-precomposed.png">
    <!-- For non-Retina iPhone, iPod Touch, and Android 2.1+ devices: -->
    <link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-precomposed.png">
    <style>
        @charset "UTF-8";
        @import url(//fonts.googleapis.com/css?family=Open+Sans:300,600,700);
        html,
        body {
            height: 100.1%;
        }
        body {
            font-family: "Open Sans", Verdana, Helvetica, Arial, sans-serif;
            line-height: 1.51803398875;
                -webkit-font-smoothing: antialiased;
                -webkit-text-size-adjust: 100%;
            text-rendering: optimizeLegibility;
        }
        #projectname { font-size: 200%; }
        #projectname img {
            vertical-align: sub;
            margin-right: .2em;
        }
    </style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <table cellspacing="0" cellpadding="0" style="width: 100%;">
        <tbody>
            <tr style="height: 56px;">
                <td id="projectalign" style="padding-left: 0.5em;">
                    <div id="projectname">
                        <img alt="" src="logo.png">
                        Photon C++ Client API
                    &#160;<span id="projectnumber">5.0.0.0</span>
                    </div>
                </td>
                <td style="width: 50%;"><gcse:search linktarget="_parent"></gcse:search></td>
            </tr>
        </tbody>
    </table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a10622.html">ExitGames</a></li><li class="navelem"><a class="el" href="a10623.html">Common</a></li><li class="navelem"><a class="el" href="a10632.html">MemoryManagement</a></li><li class="navelem"><a class="el" href="a11538.html">AllocatorInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="a11535.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AllocatorInterface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for AllocatorInterface:</div>
<div class="dyncontent">
<div class="center"><img src="a11537.gif" border="0" usemap="#_allocator_interface_inherit__map" alt="Inheritance graph"/></div>
<map name="_allocator_interface_inherit__map" id="_allocator_interface_inherit__map">
<area shape="rect" title=" " alt="" coords="63,5,171,29"/>
<area shape="rect" title=" " alt="" coords="5,77,99,101"/>
<area shape="rect" title=" " alt="" coords="123,77,245,101"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a516f69912253c6247d47104f93c7ff43"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11538.html#a516f69912253c6247d47104f93c7ff43">~AllocatorInterface</a> (void)</td></tr>
<tr class="separator:a516f69912253c6247d47104f93c7ff43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb113ae32582ca6ae31bcd7bf79ef15d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11538.html#adb113ae32582ca6ae31bcd7bf79ef15d">setMaxAllocSize</a> (size_t maxAllocSize)=0</td></tr>
<tr class="separator:adb113ae32582ca6ae31bcd7bf79ef15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae53f8335b5f25773fe796edf3bdaa03"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11538.html#aae53f8335b5f25773fe796edf3bdaa03">alloc</a> (size_t size)=0</td></tr>
<tr class="separator:aae53f8335b5f25773fe796edf3bdaa03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18411883f6ffa211ed7e094e8d42f778"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11538.html#a18411883f6ffa211ed7e094e8d42f778">dealloc</a> (void *p)=0</td></tr>
<tr class="separator:a18411883f6ffa211ed7e094e8d42f778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d4dd425702095f0fda51ec85c4ea7d"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11538.html#af5d4dd425702095f0fda51ec85c4ea7d">resize</a> (void *p, size_t size)=0</td></tr>
<tr class="separator:af5d4dd425702095f0fda51ec85c4ea7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a14ba1258bf4a2a6114a52dbf7291c75a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a11538.html">AllocatorInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a11538.html#a14ba1258bf4a2a6114a52dbf7291c75a">get</a> (void)</td></tr>
<tr class="separator:a14ba1258bf4a2a6114a52dbf7291c75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Custom Allocators to be used with Photons Memory Management need to inherit and implement this interface. The allocator that is used by Photon can be set through <a class="el" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">setAllocator()</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a516f69912253c6247d47104f93c7ff43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516f69912253c6247d47104f93c7ff43">&#9670;&nbsp;</a></span>~AllocatorInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="a11538.html">AllocatorInterface</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adb113ae32582ca6ae31bcd7bf79ef15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb113ae32582ca6ae31bcd7bf79ef15d">&#9670;&nbsp;</a></span>setMaxAllocSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setMaxAllocSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxAllocSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function gets called by <a class="el" href="a10632.html#ab22cc6204c311be2fd3ade76452b15fc">MemoryManagement::setMaxAllocSize()</a> and an implementation is required to behave as explained in the documentation of that function. </p>

</div>
</div>
<a id="aae53f8335b5f25773fe796edf3bdaa03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae53f8335b5f25773fe796edf3bdaa03">&#9670;&nbsp;</a></span>alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function gets called by <a class="el" href="a10632.html#a887a196a42f08e0f7fa136cc4c8ade5e">EG_MALLOC</a> and an implementation is required to behave as explained in the documentation of that macro. </p>

</div>
</div>
<a id="a18411883f6ffa211ed7e094e8d42f778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18411883f6ffa211ed7e094e8d42f778">&#9670;&nbsp;</a></span>dealloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void dealloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function gets called by <a class="el" href="a10632.html#a5e88070c94d33012ef229a6bd5cd141b">EG_FREE</a> and an implementation is required to behave as explained in the documentation of that macro. </p>

</div>
</div>
<a id="af5d4dd425702095f0fda51ec85c4ea7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d4dd425702095f0fda51ec85c4ea7d">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* resize </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function gets called by <a class="el" href="a10632.html#ab816ce0306f8d6409585afd846dc606f">EG_REALLOC</a> and an implementation is required to behave as explained in the documentation of that macro. </p>

</div>
</div>
<a id="a14ba1258bf4a2a6114a52dbf7291c75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ba1258bf4a2a6114a52dbf7291c75a">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a11538.html">AllocatorInterface</a>* get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function gets called by Photon exactly once in the lifetime of the application, right before the very first allocation by <a class="el" href="a10635.html">Photon</a> is made. The Allocator that is returned by this function will be used for all allocations by Photon until your code sets a different allocator through <a class="el" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">setAllocator()</a>.</p>
<p>Calling <a class="el" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">setAllocator()</a> right in the first line of main() is already too late to guarantee that every single allocation by Photon will use your custom allocator, because global and file-level static variables and constants (referred to here simply as 'globals') will be created before the program execution enters main(). If those globals are not POD-types, then they might allocate memory upon creation and in case of classes that are provided by one of the Photon libs, such allocations will happen through Photons memory management. Hence such allocations need to already use an allocator before the program enters main().</p>
<p>The way to set an allocator that is used for allocations by such globals, is to replace the default implementation of this function by your own implementation. This works in the same way like replacing the platforms default implementations of the global new and delete operators with your own implementations: Photon provides a default implementation of this function that gets used when you don't provide your own implementation, but when you do provide your own implementation, then the linker silently drops Photons weak-linked default implementation and replaces Photons call to it by a call to your implementation.</p>
<p>Usage example: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Allocator : <span class="keyword">public</span> <a class="code" href="a11538.html">ExitGames::Common::MemoryManagement::AllocatorInterface</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Allocator(<span class="keywordtype">void</span>)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> ~Allocator(<span class="keywordtype">void</span>)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a11538.html#adb113ae32582ca6ae31bcd7bf79ef15d">setMaxAllocSize</a>(<span class="keywordtype">size_t</span> maxAllocSize)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span>* <a class="code" href="a11538.html#aae53f8335b5f25773fe796edf3bdaa03">alloc</a>(<span class="keywordtype">size_t</span> size)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> malloc(size);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a11538.html#a18411883f6ffa211ed7e094e8d42f778">dealloc</a>(<span class="keywordtype">void</span>* p)</div>
<div class="line">    {</div>
<div class="line">        free(p);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span>* <a class="code" href="a11538.html#af5d4dd425702095f0fda51ec85c4ea7d">resize</a>(<span class="keywordtype">void</span>* p, <span class="keywordtype">size_t</span> size)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> realloc(p, size);</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>(size_t);</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](size_t);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="a10622.html">ExitGames</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">namespace </span>Common</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">namespace </span>MemoryManagement</div>
<div class="line">        {</div>
<div class="line">            AllocatorInterface* <a class="code" href="a11538.html#a14ba1258bf4a2a6114a52dbf7291c75a">AllocatorInterface::get</a>(<span class="keywordtype">void</span>)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// attention:</span></div>
<div class="line">                <span class="comment">// The returned pointer must already point to a valid instance at the point at which it is returned, which due to the static initialization order fiasco is not necessarily the case for a global variable.</span></div>
<div class="line">                <span class="comment">// A dynamically allocated variable however will leak, as there is no way to deallocate it, because it needs to stay valid until after the last global or file level static object that uses it has been destructed and due to the static initialization order fiasco there is no way to ensure that that deallocation happens after all those destructions.</span></div>
<div class="line">                <span class="comment">// The solution is to return the address of a function-level static variable. </span></div>
<div class="line">                <span class="keyword">static</span> Allocator allocator;</div>
<div class="line">                <span class="keywordflow">return</span> &amp;allocator;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> As you can can see, that example implementation of a primitive custom allocator makes operator new private. The reason for this is that once it had been set through <a class="el" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">setAllocator()</a> an allocator MUST stay valid until you can guarantee that all memory that was given out by it, has been returned to it. Deleting an once used allocator prematurely, even after a different allocator has been set as the current allocator, is undefined behavior and will most likely lead to an access violation crash. A static local variable of <a class="el" href="a11538.html#a14ba1258bf4a2a6114a52dbf7291c75a">AllocatorInterface::get()</a> is guaranteed by the C++ standard to be constructed before that function returns and hence it is also guaranteed by the standard to get destructed after everything that uses that allocator.</p>
<p>If however you want to manage the lifetime of an allocator instance dynamically through new and delete, then you need to keep track if some of its memory might still be in use, before you can safely delete such an allocator. A simple approach to do this is reference counting: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ReferenceCountedAllocator : <span class="keyword">public</span> <a class="code" href="a11538.html">ExitGames::Common::MemoryManagement::AllocatorInterface</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ReferenceCountedAllocator(<span class="keywordtype">void</span>)</div>
<div class="line">        : mRefCount(0)</div>
<div class="line">    {</div>
<div class="line">        retain();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ReferenceCountedAllocator* ReferenceCountedAllocator::retain(<span class="keywordtype">void</span>)</div>
<div class="line">    {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mMutex);</div>
<div class="line">        ++mRefCount;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> ReferenceCountedAllocator::release(<span class="keywordtype">void</span>)</div>
<div class="line">    {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(mMutex);</div>
<div class="line">        <span class="keywordflow">if</span>(!--mRefCount)</div>
<div class="line">        {</div>
<div class="line">            lock.unlock();</div>
<div class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a11538.html#adb113ae32582ca6ae31bcd7bf79ef15d">setMaxAllocSize</a>(<span class="keywordtype">size_t</span> maxAllocSize)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span>* <a class="code" href="a11538.html#aae53f8335b5f25773fe796edf3bdaa03">alloc</a>(<span class="keywordtype">size_t</span> size)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>(!size)</div>
<div class="line">            <span class="keywordflow">return</span> NULL;</div>
<div class="line">        retain();</div>
<div class="line">        <span class="keywordflow">return</span> malloc(size);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a11538.html#a18411883f6ffa211ed7e094e8d42f778">dealloc</a>(<span class="keywordtype">void</span>* p)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span>(!p)</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        free(p);</div>
<div class="line">        release();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span>* <a class="code" href="a11538.html#af5d4dd425702095f0fda51ec85c4ea7d">resize</a>(<span class="keywordtype">void</span>* p, <span class="keywordtype">size_t</span> size)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> realloc(p, size);</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~ReferenceCountedAllocator(<span class="keywordtype">void</span>)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> mRefCount;</div>
<div class="line">    std::mutex mMutex;</div>
<div class="line">};</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    ReferenceCountedAllocator* pAllocator = <span class="keyword">new</span> ReferenceCountedAllocator;</div>
<div class="line">    <a class="code" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">ExitGames::Common::MemoryManagement::setAllocator</a>(*pAllocator);</div>
<div class="line">    <a class="code" href="a11510.html">ExitGames::Common::JString</a> <span class="keywordtype">string</span> = L<span class="stringliteral">&quot;samplestring&quot;</span>;</div>
<div class="line">    <a class="code" href="a10632.html#a379196b09e74bed85dbeca2c0f600af1">ExitGames::Common::MemoryManagement::setAllocatorToDefault</a>();</div>
<div class="line">    pAllocator-&gt;release();</div>
<div class="line">    <span class="comment">// some more code</span></div>
<div class="line">} <span class="comment">// only at this point, when the local JString variable &#39;string&#39; gets out of scope and hence destructed, it hands its memory back to the allocator and pAllocators reference count reaches 0 so that it gets deleted</span></div>
</div><!-- fragment --><p> Note that ReferenceCountedAllocator makes its destructor private to ensure that it only ever gets called by release(). A side-effect of this is that one can't return it in <a class="el" href="a11538.html#a14ba1258bf4a2a6114a52dbf7291c75a">AllocatorInterface::get()</a> (at least without leaking it). So there are usage scenarios for the approaches of both example custom allocators: use the approach of class Allocator for a custom allocator that should be returned by <a class="el" href="a11538.html#a14ba1258bf4a2a6114a52dbf7291c75a">AllocatorInterface::get()</a>, and use the approach of ReferenceCountedAllocator for a custom allocator that should be able to have a limited lifetime.</p>
<p>Furthermore note that your custom allocator must be thread-safe (which would not be the case for ReferenceCountedAllocator, if it would not protect mRefCount with a lock), as <a class="el" href="a10635.html">Photon</a> might access it from multiple threads at once.</p>
<p>Finally if for some reason you don't want any allocations on the heap to happen while global and file level static variables are getting constructed, remember that it is completely up to you where the memory that you provide to Photon is coming from and how it's managed and that you can provide different allocators at different times. Hence the allocator that you return by <a class="el" href="a11538.html#a14ba1258bf4a2a6114a52dbf7291c75a">AllocatorInterface::get()</a> could look like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Allocator : <span class="keyword">public</span> <a class="code" href="a11538.html">ExitGames::Common::MemoryManagement::AllocatorInterface</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Allocator(<span class="keywordtype">void</span>)</div>
<div class="line">        : mCountBytes(0)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> ~Allocator(<span class="keywordtype">void</span>)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a11538.html#adb113ae32582ca6ae31bcd7bf79ef15d">setMaxAllocSize</a>(<span class="keywordtype">size_t</span> maxAllocSize)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span>* <a class="code" href="a11538.html#aae53f8335b5f25773fe796edf3bdaa03">alloc</a>(<span class="keywordtype">size_t</span> size)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> MEM_SIZE = 16*1024;</div>
<div class="line">        <span class="keyword">static</span> <span class="keywordtype">byte</span> memory[MEM_SIZE];</div>
<div class="line">        mCountBytes += size;</div>
<div class="line">        <span class="keywordflow">if</span>(mCountBytes &gt; MEM_SIZE)</div>
<div class="line">            assert(<span class="keyword">false</span>);</div>
<div class="line">        <span class="keywordflow">return</span> memory+mCountBytes-size;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a11538.html#a18411883f6ffa211ed7e094e8d42f778">dealloc</a>(<span class="keywordtype">void</span>* p)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span>* <a class="code" href="a11538.html#af5d4dd425702095f0fda51ec85c4ea7d">resize</a>(<span class="keywordtype">void</span>* p, <span class="keywordtype">size_t</span> size)</div>
<div class="line">    {</div>
<div class="line">        assert(<span class="keyword">false</span>);</div>
<div class="line">        <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>(size_t);</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](size_t);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> mCountBytes;</div>
<div class="line">};</div>
</div><!-- fragment --><p> This variant simply allocates the memory on a static byte-array and does not reuse any memory that is returned to it (which is perfectly fine for memory that gets allocated in the constructor and deallocated in the destructor of a variable which has the same lifetime as the executable).</p>
<p>Note that you need to make sure that the array on which the memory is allocated is big enough to cover all requests that occur until you set a different allocator. As the required amount might change when changes in your code happen or when you update to a new Photon version, the assert() in alloc is important to avoid hard to track down crashes in unrelated code.</p>
<p>Be aware that this primitive variant that does not reuse any memory only makes sense when you set a different allocator through <a class="el" href="a10632.html#ada9ca1c31b7e751410dfa14807176672">setAllocator()</a> as early as possible because the longer you wait the bigger the static array will need to be to serve all requests without running out of memory. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aa11538_html"><div class="ttname"><a href="a11538.html">ExitGames::Common::MemoryManagement::AllocatorInterface</a></div><div class="ttdef"><b>Definition:</b> AllocatorInterface.h:20</div></div>
<div class="ttc" id="aa11538_html_aae53f8335b5f25773fe796edf3bdaa03"><div class="ttname"><a href="a11538.html#aae53f8335b5f25773fe796edf3bdaa03">ExitGames::Common::MemoryManagement::AllocatorInterface::alloc</a></div><div class="ttdeci">virtual void * alloc(size_t size)=0</div></div>
<div class="ttc" id="aa11538_html_a18411883f6ffa211ed7e094e8d42f778"><div class="ttname"><a href="a11538.html#a18411883f6ffa211ed7e094e8d42f778">ExitGames::Common::MemoryManagement::AllocatorInterface::dealloc</a></div><div class="ttdeci">virtual void dealloc(void *p)=0</div></div>
<div class="ttc" id="aa10632_html_a379196b09e74bed85dbeca2c0f600af1"><div class="ttname"><a href="a10632.html#a379196b09e74bed85dbeca2c0f600af1">ExitGames::Common::MemoryManagement::setAllocatorToDefault</a></div><div class="ttdeci">void setAllocatorToDefault(void)</div><div class="ttdef"><b>Definition:</b> Allocate.cpp:103</div></div>
<div class="ttc" id="aa11538_html_a14ba1258bf4a2a6114a52dbf7291c75a"><div class="ttname"><a href="a11538.html#a14ba1258bf4a2a6114a52dbf7291c75a">ExitGames::Common::MemoryManagement::AllocatorInterface::get</a></div><div class="ttdeci">static AllocatorInterface * get(void)</div></div>
<div class="ttc" id="aa10622_html"><div class="ttname"><a href="a10622.html">ExitGames</a></div><div class="ttdef"><b>Definition:</b> ANSIString.h:11</div></div>
<div class="ttc" id="aa11538_html_af5d4dd425702095f0fda51ec85c4ea7d"><div class="ttname"><a href="a11538.html#af5d4dd425702095f0fda51ec85c4ea7d">ExitGames::Common::MemoryManagement::AllocatorInterface::resize</a></div><div class="ttdeci">virtual void * resize(void *p, size_t size)=0</div></div>
<div class="ttc" id="aa11538_html_adb113ae32582ca6ae31bcd7bf79ef15d"><div class="ttname"><a href="a11538.html#adb113ae32582ca6ae31bcd7bf79ef15d">ExitGames::Common::MemoryManagement::AllocatorInterface::setMaxAllocSize</a></div><div class="ttdeci">virtual void setMaxAllocSize(size_t maxAllocSize)=0</div></div>
<div class="ttc" id="aa10632_html_ada9ca1c31b7e751410dfa14807176672"><div class="ttname"><a href="a10632.html#ada9ca1c31b7e751410dfa14807176672">ExitGames::Common::MemoryManagement::setAllocator</a></div><div class="ttdeci">void setAllocator(ExitGames::Common::MemoryManagement::AllocatorInterface &amp;allocator)</div><div class="ttdef"><b>Definition:</b> Allocate.cpp:94</div></div>
<div class="ttc" id="aa11510_html"><div class="ttname"><a href="a11510.html">ExitGames::Common::JString</a></div><div class="ttdef"><b>Definition:</b> JString.h:23</div></div>
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<footer style="border-top: 1px solid #444; margin-top: 1em; padding: 1em;">
    <div style="float: left;">
        &copy;&nbsp;<a href="https://www.photonengine.com/"> Exit Games &reg;</a>, all rights reserved.
    </div>
    <div style="float: right;">
        <a href="http://doc.photonengine.com/">Photon Documentation</a> |
        <a href="http://www.photonengine.com/en/contact">Contact</a> |
        <a href="https://www.photonengine.com/en/account/terms">Terms</a>
    <div>
    <b style="clear: both;"></b>
</footer>
<script>
  (function() {
    var cx = '015653142792304683059:ykdoyzkcyu4';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
</body>
</html>